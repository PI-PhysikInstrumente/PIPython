{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"PIPython The PIPython package is a collection of Python modules for the communication with PI controllers and for processing GCS data. PIPython is compatible with Python 3.6+ on Windows, Linux, and OS X, and without the GCS DLL on any other platform as well. Installation PIPython as well as the samples folder can be downloaded from GitHub . By installing PIPython you agree to the license agreement . Installing from local folder Unzip the file PIPython.zip , open a command entry (Linux Console or Windows CMD window) and run: python setup.py install Installing from GitHub git clone git @github . com : PI - PhysikInstrumente / PIPython . git python setup . py install Installing from pypi.org pip install PIPython Any questions? If you have any questions, don't hesitate - just send an e-mail to service@pi.de We would also appreciate your feedback.","title":"Home"},{"location":"index.html#pipython","text":"The PIPython package is a collection of Python modules for the communication with PI controllers and for processing GCS data. PIPython is compatible with Python 3.6+ on Windows, Linux, and OS X, and without the GCS DLL on any other platform as well.","title":"PIPython"},{"location":"index.html#installation","text":"PIPython as well as the samples folder can be downloaded from GitHub . By installing PIPython you agree to the license agreement . Installing from local folder Unzip the file PIPython.zip , open a command entry (Linux Console or Windows CMD window) and run: python setup.py install Installing from GitHub git clone git @github . com : PI - PhysikInstrumente / PIPython . git python setup . py install Installing from pypi.org pip install PIPython Any questions? If you have any questions, don't hesitate - just send an e-mail to service@pi.de We would also appreciate your feedback.","title":"Installation"},{"location":"connect.html","text":"Device Connection Connecting to a single device with the GCS DLL Via dialog On Windows systems the GCS DLL provides a graphical user interface to select the connection parameters. from pipython import GCSDevice with GCSDevice () as pidevice : pidevice . InterfaceSetupDlg () print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ())) If you pass a string as the optional key argument to the InterfaceSetupDlg method, the DLL stores the settings in the Windows registry and retrieves them the next time you connect with the same key. from pipython import GCSDevice with GCSDevice () as pidevice : pidevice . InterfaceSetupDlg ( 'MyTest' ) print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ())) Via device identification There are functions to scan for available devices: Interface Function USB EnumerateUSB(mask='') TCP/IP EnumerateTCPIPDevices(mask='') Use mask (= string) to limit the number of devices to be found. If it is contained in the device identification, the device is found - see qIDN . from pipython import GCSDevice with GCSDevice () as pidevice : devices = pidevice . EnumerateTCPIPDevices ( mask = 'C-884.4DB' ) for i , device in enumerate ( devices ): print ( ' {} - {} ' . format ( i , device )) item = int ( input ( 'Select device to connect:' )) pidevice . ConnectTCPIPByDescription ( devices [ item ]) print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ())) Via dedicated interface You can connect to a device via the following interfaces using the corresponding methods: Interface Method RS-232 ConnectRS232(comport, baudrate) USB ConnectUSB(serialnum) serialnum = the device's serial number as a string or the device identification returned by the EnumerateUSB method TCP/IP ConnectTCPIP(ipaddress, ipport=50000) TCP/IP ConnectTCPIPByDescription(description) description = string returned by the EnumerateTCPIPDevices method NI GPIB ConnectNIgpib(board, device) PCI board ConnectPciBoard(board) from pipython import GCSDevice with GCSDevice () as pidevice : pidevice . ConnectTCPIP ( '192.168.178.42' ) # Use the default port print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ())) Connecting to devices in a daisy chain network Open the interface to the daisy chain master device (i.e., the device connected to the PC), then connect all devices of the daisy chain network to this interface. Info In a daisy chain network, each device must have a unique address (= device ID). There must be one device with the address 1, though this device does not have to be the master device (see controller manual on how to change the address of a device). Use the following methods to connect to the master device in a daisy chain network: Interface Method RS-232 OpenRS232DaisyChain(comport, baudrate) USB OpenUSBDaisyChain(serialnum) TCP/IP OpenTCPIPDaisyChain(ipaddress, ipport=50000) In the following example, three controllers are being connected: C-863 controller as the master device, address 3 E-861 controller, address 7 C-867 controller, address 1 from pipython import GCSDevice with GCSDevice () as c863 : c863 . OpenRS232DaisyChain ( comport = 1 , baudrate = 115200 ) # c863.OpenUSBDaisyChain(description='1234567890') # c863.OpenTCPIPDaisyChain(ipaddress='192.168.178.42') daisychainid = c863 . dcid c863 . ConnectDaisyChainDevice ( 3 , daisychainid ) with GCSDevice () as e861 : e861 . ConnectDaisyChainDevice ( 7 , daisychainid ) with GCSDevice () as c867 : c867 . ConnectDaisyChainDevice ( 1 , daisychainid ) print ( ' \\n {} : \\n {} ' . format ( c863 . GetInterfaceDescription (), c863 . qIDN ())) print ( ' \\n {} : \\n {} ' . format ( e861 . GetInterfaceDescription (), e861 . qIDN ())) print ( ' \\n {} : \\n {} ' . format ( c867 . GetInterfaceDescription (), c867 . qIDN ())) Connecting via low-level interface The preferred method for connecting to devices is GCSDevice using the GCS DLL. However, on platforms where the GCS DLL is not available, low-level functions of the PIPython package can be used instead. Interface Method RS-232 PISerial(comport, baudrate) USB PIUSB(serialnum) TCP/IP PISocket(ipaddress, ipport=50000) PISerial from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piserial import PISerial with PISerial ( port = 1 , baudrate = 115200 ) as gateway : messages = GCSMessages ( gateway ) pidevice = GCSCommands ( messages ) print ( pidevice . qIDN ()) PIUSB from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piusb import PIUSB with PIUSB () as gateway : gateway . connect ( serialnumber = '1234567890' , pid = 0x1234 ) messages = GCSMessages ( gateway ) pidevice = GCSCommands ( messages ) print ( pidevice . qIDN ()) PISocket from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.pisocket import PISocket with PISocket ( host = '192.168.178.42' , port = 50000 ) as gateway : messages = GCSMessages ( gateway ) pidevice = GCSCommands ( messages ) print ( pidevice . qIDN ()) Connecting to unknown devices If GCSDevice is called with the controller name, the corresponding GCS DLL is chosen automatically. For unknown devices, a dedicated GCS DLL can be used instead. from pipython import GCSDevice with GCSDevice ( gcsdll = 'PI_GCS2_DLL.dll' ) as pidevice : pidevice . InterfaceSetupDlg ()","title":"Device Connection"},{"location":"connect.html#device-connection","text":"","title":"Device Connection"},{"location":"connect.html#connecting-to-a-single-device-with-the-gcs-dll","text":"","title":"Connecting to a single device with the GCS DLL"},{"location":"connect.html#via-dialog","text":"On Windows systems the GCS DLL provides a graphical user interface to select the connection parameters. from pipython import GCSDevice with GCSDevice () as pidevice : pidevice . InterfaceSetupDlg () print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ())) If you pass a string as the optional key argument to the InterfaceSetupDlg method, the DLL stores the settings in the Windows registry and retrieves them the next time you connect with the same key. from pipython import GCSDevice with GCSDevice () as pidevice : pidevice . InterfaceSetupDlg ( 'MyTest' ) print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ()))","title":"Via dialog"},{"location":"connect.html#via-device-identification","text":"There are functions to scan for available devices: Interface Function USB EnumerateUSB(mask='') TCP/IP EnumerateTCPIPDevices(mask='') Use mask (= string) to limit the number of devices to be found. If it is contained in the device identification, the device is found - see qIDN . from pipython import GCSDevice with GCSDevice () as pidevice : devices = pidevice . EnumerateTCPIPDevices ( mask = 'C-884.4DB' ) for i , device in enumerate ( devices ): print ( ' {} - {} ' . format ( i , device )) item = int ( input ( 'Select device to connect:' )) pidevice . ConnectTCPIPByDescription ( devices [ item ]) print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ()))","title":"Via device identification"},{"location":"connect.html#via-dedicated-interface","text":"You can connect to a device via the following interfaces using the corresponding methods: Interface Method RS-232 ConnectRS232(comport, baudrate) USB ConnectUSB(serialnum) serialnum = the device's serial number as a string or the device identification returned by the EnumerateUSB method TCP/IP ConnectTCPIP(ipaddress, ipport=50000) TCP/IP ConnectTCPIPByDescription(description) description = string returned by the EnumerateTCPIPDevices method NI GPIB ConnectNIgpib(board, device) PCI board ConnectPciBoard(board) from pipython import GCSDevice with GCSDevice () as pidevice : pidevice . ConnectTCPIP ( '192.168.178.42' ) # Use the default port print ( 'connected: {} ' . format ( pidevice . qIDN () . strip ()))","title":"Via dedicated interface"},{"location":"connect.html#connecting-to-devices-in-a-daisy-chain-network","text":"Open the interface to the daisy chain master device (i.e., the device connected to the PC), then connect all devices of the daisy chain network to this interface. Info In a daisy chain network, each device must have a unique address (= device ID). There must be one device with the address 1, though this device does not have to be the master device (see controller manual on how to change the address of a device). Use the following methods to connect to the master device in a daisy chain network: Interface Method RS-232 OpenRS232DaisyChain(comport, baudrate) USB OpenUSBDaisyChain(serialnum) TCP/IP OpenTCPIPDaisyChain(ipaddress, ipport=50000) In the following example, three controllers are being connected: C-863 controller as the master device, address 3 E-861 controller, address 7 C-867 controller, address 1 from pipython import GCSDevice with GCSDevice () as c863 : c863 . OpenRS232DaisyChain ( comport = 1 , baudrate = 115200 ) # c863.OpenUSBDaisyChain(description='1234567890') # c863.OpenTCPIPDaisyChain(ipaddress='192.168.178.42') daisychainid = c863 . dcid c863 . ConnectDaisyChainDevice ( 3 , daisychainid ) with GCSDevice () as e861 : e861 . ConnectDaisyChainDevice ( 7 , daisychainid ) with GCSDevice () as c867 : c867 . ConnectDaisyChainDevice ( 1 , daisychainid ) print ( ' \\n {} : \\n {} ' . format ( c863 . GetInterfaceDescription (), c863 . qIDN ())) print ( ' \\n {} : \\n {} ' . format ( e861 . GetInterfaceDescription (), e861 . qIDN ())) print ( ' \\n {} : \\n {} ' . format ( c867 . GetInterfaceDescription (), c867 . qIDN ()))","title":"Connecting to devices in a daisy chain network"},{"location":"connect.html#connecting-via-low-level-interface","text":"The preferred method for connecting to devices is GCSDevice using the GCS DLL. However, on platforms where the GCS DLL is not available, low-level functions of the PIPython package can be used instead. Interface Method RS-232 PISerial(comport, baudrate) USB PIUSB(serialnum) TCP/IP PISocket(ipaddress, ipport=50000) PISerial from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piserial import PISerial with PISerial ( port = 1 , baudrate = 115200 ) as gateway : messages = GCSMessages ( gateway ) pidevice = GCSCommands ( messages ) print ( pidevice . qIDN ()) PIUSB from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piusb import PIUSB with PIUSB () as gateway : gateway . connect ( serialnumber = '1234567890' , pid = 0x1234 ) messages = GCSMessages ( gateway ) pidevice = GCSCommands ( messages ) print ( pidevice . qIDN ()) PISocket from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.pisocket import PISocket with PISocket ( host = '192.168.178.42' , port = 50000 ) as gateway : messages = GCSMessages ( gateway ) pidevice = GCSCommands ( messages ) print ( pidevice . qIDN ())","title":"Connecting via low-level interface"},{"location":"connect.html#connecting-to-unknown-devices","text":"If GCSDevice is called with the controller name, the corresponding GCS DLL is chosen automatically. For unknown devices, a dedicated GCS DLL can be used instead. from pipython import GCSDevice with GCSDevice ( gcsdll = 'PI_GCS2_DLL.dll' ) as pidevice : pidevice . InterfaceSetupDlg ()","title":"Connecting to unknown devices"},{"location":"datarecorder20.html","text":"Data Recorder GCS 2.0 Info These instructions are valid for controllers using GCS 2.0. A PI device has one or more record tables that can be filled with data (i.e. values) from a configurable source. PIPython comes with Datarecorder class for the configuration of data recording: pipython.datarectools.Datarecorder . from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... In the further examples on this page, pidevice refers to an instance of pipython.GCSDevice and drec refers to an instance of pipython.datarectools.Datarecorder . The typical workflow for data recording is as follows: Preparing the data recorder Recording data Reading out the recorded data Processing the recorded data For an example see samples/datarecorder.py . Preparing the data recorder The configuration of data recording consists of the following steps: Setting the record rate Setting the record time Setting the record source and options Setting the trigger event Setting the record rate With the Datarecorder property samplerate you can configure the record rate in multiples of the controller-specific servo cycle time. The higher the record rate, the slower the data is recorded. With the property sampletime you can configure the record rate in seconds. With the property samplefrequ you can configure the record rate in hertz. These properties use the GCS command RTR to configure the record table rate on the device. # drec.samplerate = 1 # drec.sampletime = 1E-5 drec . samplefrequ = 1000 print ( 'data recorder rate: {:d} servo cycles' . format ( drec . samplerate )) print ( 'data recorder rate: {:.g} seconds' . format ( drec . sampletime )) print ( 'data recorder rate: {:.2f} Hertz' . format ( drec . samplefrequ )) Setting the record time By default the entire data recorder buffer is used to record data. The Datarecorder class offers two properties to limit the data to be recorded: numvalues : number of data points to be recorded rectime : record time in seconds Setting one of these properties will change the other accordingly. Use the rectimemax property to use the entire data recorder buffer and adjust samplerate accordingly. Setting the record source and options With the Datarecorder property options you can configure which record option (measurement) is to be recorded in a specified record table . The record options are avaiable via pipython.datarectools.RecordOptions . With the property sources you can configure which record source (e.g. an axis or channel) is to be recorded in a specified record table . The properties options and source can each get either a list of values or a single value as argument. If options is a single value and sources is a list, option is used for all sources . If sources is a single value and options is a list, the options are used for the single source . If both are lists, the lists must contain the same number of elements. The fist option is used for the first source and recorded to record table 1, the second option is used for the second source and recorded to record table 2, and so on. If no record option is specified, RecordOptions.ACTUAL_POSITION_2 is used. If no source is specified, all connected axes are used. Examples: Set the recording of two values for one axis drec . options = [ datarectools . RecordOptions . ACTUAL_POSITION_2 , datarectools . RecordOptions . COMMANDED_POSITION_1 ] drec . sources = pidevice . axes [ 0 ] Set the recording of one value for two axes drec . options = datarectools . RecordOptions . ACTUAL_POSITION_2 drec . sources = [ 'X' , 'Y' ] Configure four recordings: record option 81 for analog input lines 1 and 2, record option 73 for axis X, and record option 1 for axis Y drec . sources = [ 1 , 2 , 'X' , 'Y' ] drec . options = [ datarectools . RecordOptions . ANALOG_INPUT_81 , datarectools . RecordOptions . ANALOG_INPUT_81 , datarectools . RecordOptions . MOTOR_OUTPUT_73 , datarectools . RecordOptions . COMMANDED_POSITION_1 ] Setting the trigger event With the Datarecorder property trigsources you can specify when the recording is to be started, e.g. immediately or with the next command that changes a position . The trigger events are avaiable via pipython.datarectools.TriggerSources . The property trigsources can get either a list of values or a single value as trigger option argument. If you set the property trigsources with a single value, this trigger option is used with all record tables. The shortcut for \"to be used for all record tables\" is the record table ID \"0\". (Please note that \"real\" record table IDs start with \"1\".) If trigsources is called with a list as argument, the trigger options will be used with the corresponding record table IDs: The fist trigger option is used for record table 1, the second for record table 2, and so on. If no trigger event is specified, TriggerSources.NEXT_COMMAND_WITH_RESET_2 is used. Using this event deactivates the error check. Note Please note that not all controllers support a record table dependent trigger source. Such controllers only support one trigger source for all record tables. See the controller's user manual to find out which is the appropriate way for your device. Examples: Configure two recordings for one axis triggered by a position changing command drec . options = ( datarectools . RecordOptions . ACTUAL_POSITION_2 , datarectools . RecordOptions . COMMANDED_POSITION_1 ) drec . sources = pidevice . axes [ 0 ] drec . trigsources = datarectools . TriggerSources . POSITION_CHANGING_COMMAND_1 Set 'trigsources' to a position changing command for record table 1, and \"triggerd by the next GCS command\" for record table 2 ... drec . trigsources = ( datarectools . TriggerSources . POSITION_CHANGING_COMMAND_1 , datarectools . TriggerSources . NEXT_COMMAND_WITH_RESET_2 ) ... Useful helper functions The helper functions getrecopt() and gettrigsources() enable converting a descriptive string, e.g., from an INI file, into the corresponding option value. These functions split the string argument by the underscore delimiter (\"_\") and return the first option that matches all elements of the string. Matches are not case-sensitive and may be abbreviated. Abbreviations must start with the first letter of the option name element, e.g., \"pos_chg_cmd\" for \"POSITION_CHANGING_COMMAND_1\". The following example sets the trigger source to \"POSITION_CHANGING_COMMAND_1\" using a descriptive string. desc = 'pos_chg_cmd' # descriptive string, e.g. from INI file drec . trigsources = datarectools . gettrigsources ( readout ) Recording data Starting the recording The method Datarecorder.arm() arms the data recorder, i.e., prepares it for the actual recording by writing the record sources and options for the data recorder to the device writing the trigger events for the record tables to the device When armed, the data recorder starts recording as soon as the specified trigger event occurs. drec . options = datarectools . RecordOptions . ACTUAL_POSITION_2 drec . sources = [ 'X' , 'Y' ] drec . trigsources = datarectools . TriggerSources . POSITION_CHANGING_COMMAND_1 drec . arm () Waiting for the recording to finish To wait for the triggered motion to finish, you can use the \"wait\" helper functions in pipython.pitools , for example waitontarget() . The function halts the application until the triggered motion has finished. It is called with an instance of pidevice and a single or a list of axis identifiers (string or integer). ... pidevice . MVR ([ 'X' , 'Y' ], [ 1.0 , 2.0 ]) pitools . waitontarget ( pidevice , [ 'X' , 'Y' ]) ... If the application is supposed to continue immediately after the data recorder has stopped recording, regardless of a motion having finished, the Datarecorder.wait() function may be used. drec . arm () # data is being recorded if trigger event occurs drec . wait () # recording has finished Reading out the recorded data Recorded data can be read with the function getdata() . If you used Datarecorder.wait() , use the function Datarecorder.read() instead of getdata() . ... header , data = drec . getdata () ... drec . arm () drec . wait () header , data = drec . read () Both functions call the GCS command qDDR() and wait for the recording to finish. Then they return the header and the data as a two-dimensional list with the first index indicating the record table and the second index indicating the recorded values in the table. If you don't want to wait until the recording has finished - as this could take a while, depending on the amount of data and the interface - you can call the GCS command qDRR directly. qDRR returns immediately with the GCS header containing information on the recorded data. Then it starts a background task which internally buffers the data from the device as it is being transmitted. The status of the internal buffer can be queried with the GCSDevice.bufstate property. It indicates the transmission progress by float values in the range 0...1 and becomes True when the transmission has completed. Hence end a loop with while bufstate is not True and not with while not bufstate . header = pidevice . qDRR ( rectables , offset , numvalues ) while pidevice . bufstate is not True : print ( 'Reading data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) Warning The background task will lock any communication to the device for the duration of the data transmission. This means that although your application is actually able to continue after having called the qDRR command, any attempt on communication with the device will result in a deadlock. To prevent this always check pidevice.bufstate . Processing the recorded data Displaying the data with matplotlib The following example shows how to use the header and data from a recording stored in two record tables to create a plot. This requires matplotlib. timescale = [ header [ 'SAMPLE_TIME' ] * i for i in range ( len ( data [ 0 ]))] pyplot . plot ( timescale , data [ 0 ], color = 'red' ) pyplot . plot ( timescale , data [ 1 ], color = 'blue' ) pyplot . xlabel ( 'time (s)' ) pyplot . ylabel ( ', ' . join (( header [ 'NAME0' ], header [ 'NAME1' ]))) pyplot . title ( 'Recorded data over time' ) pyplot . grid ( True ) pyplot . show () Converting the data into a NumPy array If you are used to NumPy you can easily convert the recorded data into a NumPy array. import numpy as np ... header , data = drec . getdata () npdata = np . array ( data )","title":"Data Recorder GCS 2.0"},{"location":"datarecorder20.html#data-recorder-gcs-20","text":"Info These instructions are valid for controllers using GCS 2.0. A PI device has one or more record tables that can be filled with data (i.e. values) from a configurable source. PIPython comes with Datarecorder class for the configuration of data recording: pipython.datarectools.Datarecorder . from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... In the further examples on this page, pidevice refers to an instance of pipython.GCSDevice and drec refers to an instance of pipython.datarectools.Datarecorder . The typical workflow for data recording is as follows: Preparing the data recorder Recording data Reading out the recorded data Processing the recorded data For an example see samples/datarecorder.py .","title":"Data Recorder GCS 2.0"},{"location":"datarecorder20.html#preparing-the-data-recorder","text":"The configuration of data recording consists of the following steps: Setting the record rate Setting the record time Setting the record source and options Setting the trigger event","title":"Preparing the data recorder"},{"location":"datarecorder20.html#setting-the-record-rate","text":"With the Datarecorder property samplerate you can configure the record rate in multiples of the controller-specific servo cycle time. The higher the record rate, the slower the data is recorded. With the property sampletime you can configure the record rate in seconds. With the property samplefrequ you can configure the record rate in hertz. These properties use the GCS command RTR to configure the record table rate on the device. # drec.samplerate = 1 # drec.sampletime = 1E-5 drec . samplefrequ = 1000 print ( 'data recorder rate: {:d} servo cycles' . format ( drec . samplerate )) print ( 'data recorder rate: {:.g} seconds' . format ( drec . sampletime )) print ( 'data recorder rate: {:.2f} Hertz' . format ( drec . samplefrequ ))","title":"Setting the record rate"},{"location":"datarecorder20.html#setting-the-record-time","text":"By default the entire data recorder buffer is used to record data. The Datarecorder class offers two properties to limit the data to be recorded: numvalues : number of data points to be recorded rectime : record time in seconds Setting one of these properties will change the other accordingly. Use the rectimemax property to use the entire data recorder buffer and adjust samplerate accordingly.","title":"Setting the record time"},{"location":"datarecorder20.html#setting-the-record-source-and-options","text":"With the Datarecorder property options you can configure which record option (measurement) is to be recorded in a specified record table . The record options are avaiable via pipython.datarectools.RecordOptions . With the property sources you can configure which record source (e.g. an axis or channel) is to be recorded in a specified record table . The properties options and source can each get either a list of values or a single value as argument. If options is a single value and sources is a list, option is used for all sources . If sources is a single value and options is a list, the options are used for the single source . If both are lists, the lists must contain the same number of elements. The fist option is used for the first source and recorded to record table 1, the second option is used for the second source and recorded to record table 2, and so on. If no record option is specified, RecordOptions.ACTUAL_POSITION_2 is used. If no source is specified, all connected axes are used. Examples: Set the recording of two values for one axis drec . options = [ datarectools . RecordOptions . ACTUAL_POSITION_2 , datarectools . RecordOptions . COMMANDED_POSITION_1 ] drec . sources = pidevice . axes [ 0 ] Set the recording of one value for two axes drec . options = datarectools . RecordOptions . ACTUAL_POSITION_2 drec . sources = [ 'X' , 'Y' ] Configure four recordings: record option 81 for analog input lines 1 and 2, record option 73 for axis X, and record option 1 for axis Y drec . sources = [ 1 , 2 , 'X' , 'Y' ] drec . options = [ datarectools . RecordOptions . ANALOG_INPUT_81 , datarectools . RecordOptions . ANALOG_INPUT_81 , datarectools . RecordOptions . MOTOR_OUTPUT_73 , datarectools . RecordOptions . COMMANDED_POSITION_1 ]","title":"Setting the record source and options"},{"location":"datarecorder20.html#setting-the-trigger-event","text":"With the Datarecorder property trigsources you can specify when the recording is to be started, e.g. immediately or with the next command that changes a position . The trigger events are avaiable via pipython.datarectools.TriggerSources . The property trigsources can get either a list of values or a single value as trigger option argument. If you set the property trigsources with a single value, this trigger option is used with all record tables. The shortcut for \"to be used for all record tables\" is the record table ID \"0\". (Please note that \"real\" record table IDs start with \"1\".) If trigsources is called with a list as argument, the trigger options will be used with the corresponding record table IDs: The fist trigger option is used for record table 1, the second for record table 2, and so on. If no trigger event is specified, TriggerSources.NEXT_COMMAND_WITH_RESET_2 is used. Using this event deactivates the error check. Note Please note that not all controllers support a record table dependent trigger source. Such controllers only support one trigger source for all record tables. See the controller's user manual to find out which is the appropriate way for your device. Examples: Configure two recordings for one axis triggered by a position changing command drec . options = ( datarectools . RecordOptions . ACTUAL_POSITION_2 , datarectools . RecordOptions . COMMANDED_POSITION_1 ) drec . sources = pidevice . axes [ 0 ] drec . trigsources = datarectools . TriggerSources . POSITION_CHANGING_COMMAND_1 Set 'trigsources' to a position changing command for record table 1, and \"triggerd by the next GCS command\" for record table 2 ... drec . trigsources = ( datarectools . TriggerSources . POSITION_CHANGING_COMMAND_1 , datarectools . TriggerSources . NEXT_COMMAND_WITH_RESET_2 ) ... Useful helper functions The helper functions getrecopt() and gettrigsources() enable converting a descriptive string, e.g., from an INI file, into the corresponding option value. These functions split the string argument by the underscore delimiter (\"_\") and return the first option that matches all elements of the string. Matches are not case-sensitive and may be abbreviated. Abbreviations must start with the first letter of the option name element, e.g., \"pos_chg_cmd\" for \"POSITION_CHANGING_COMMAND_1\". The following example sets the trigger source to \"POSITION_CHANGING_COMMAND_1\" using a descriptive string. desc = 'pos_chg_cmd' # descriptive string, e.g. from INI file drec . trigsources = datarectools . gettrigsources ( readout )","title":"Setting the trigger event"},{"location":"datarecorder20.html#recording-data","text":"","title":"Recording data"},{"location":"datarecorder20.html#starting-the-recording","text":"The method Datarecorder.arm() arms the data recorder, i.e., prepares it for the actual recording by writing the record sources and options for the data recorder to the device writing the trigger events for the record tables to the device When armed, the data recorder starts recording as soon as the specified trigger event occurs. drec . options = datarectools . RecordOptions . ACTUAL_POSITION_2 drec . sources = [ 'X' , 'Y' ] drec . trigsources = datarectools . TriggerSources . POSITION_CHANGING_COMMAND_1 drec . arm ()","title":"Starting the recording"},{"location":"datarecorder20.html#waiting-for-the-recording-to-finish","text":"To wait for the triggered motion to finish, you can use the \"wait\" helper functions in pipython.pitools , for example waitontarget() . The function halts the application until the triggered motion has finished. It is called with an instance of pidevice and a single or a list of axis identifiers (string or integer). ... pidevice . MVR ([ 'X' , 'Y' ], [ 1.0 , 2.0 ]) pitools . waitontarget ( pidevice , [ 'X' , 'Y' ]) ... If the application is supposed to continue immediately after the data recorder has stopped recording, regardless of a motion having finished, the Datarecorder.wait() function may be used. drec . arm () # data is being recorded if trigger event occurs drec . wait () # recording has finished","title":"Waiting for the recording to finish"},{"location":"datarecorder20.html#reading-out-the-recorded-data","text":"Recorded data can be read with the function getdata() . If you used Datarecorder.wait() , use the function Datarecorder.read() instead of getdata() . ... header , data = drec . getdata () ... drec . arm () drec . wait () header , data = drec . read () Both functions call the GCS command qDDR() and wait for the recording to finish. Then they return the header and the data as a two-dimensional list with the first index indicating the record table and the second index indicating the recorded values in the table. If you don't want to wait until the recording has finished - as this could take a while, depending on the amount of data and the interface - you can call the GCS command qDRR directly. qDRR returns immediately with the GCS header containing information on the recorded data. Then it starts a background task which internally buffers the data from the device as it is being transmitted. The status of the internal buffer can be queried with the GCSDevice.bufstate property. It indicates the transmission progress by float values in the range 0...1 and becomes True when the transmission has completed. Hence end a loop with while bufstate is not True and not with while not bufstate . header = pidevice . qDRR ( rectables , offset , numvalues ) while pidevice . bufstate is not True : print ( 'Reading data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) Warning The background task will lock any communication to the device for the duration of the data transmission. This means that although your application is actually able to continue after having called the qDRR command, any attempt on communication with the device will result in a deadlock. To prevent this always check pidevice.bufstate .","title":"Reading out the recorded data"},{"location":"datarecorder20.html#processing-the-recorded-data","text":"","title":"Processing the recorded data"},{"location":"datarecorder20.html#displaying-the-data-with-matplotlib","text":"The following example shows how to use the header and data from a recording stored in two record tables to create a plot. This requires matplotlib. timescale = [ header [ 'SAMPLE_TIME' ] * i for i in range ( len ( data [ 0 ]))] pyplot . plot ( timescale , data [ 0 ], color = 'red' ) pyplot . plot ( timescale , data [ 1 ], color = 'blue' ) pyplot . xlabel ( 'time (s)' ) pyplot . ylabel ( ', ' . join (( header [ 'NAME0' ], header [ 'NAME1' ]))) pyplot . title ( 'Recorded data over time' ) pyplot . grid ( True ) pyplot . show ()","title":"Displaying the data with matplotlib"},{"location":"datarecorder20.html#converting-the-data-into-a-numpy-array","text":"If you are used to NumPy you can easily convert the recorded data into a NumPy array. import numpy as np ... header , data = drec . getdata () npdata = np . array ( data )","title":"Converting the data into a NumPy array"},{"location":"datarecorder30.html","text":"Data Recorder GCS 3.0 Info These instructions are valid for controllers using GCS 3.0. A PI device has one or more record tables that can be filled with data (i.e. values) from a configurable source. PIPython comes with Datarecorder class for the configuration of data recording: pipython.datarectools.Datarecorder . from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... In the further examples on this page, pidevice refers to an instance of pipython.GCSDevice and drec refers to an instance of pipython.datarectools.Datarecorder . The typical workflow for data recording is as follows: Preparing the data recorder Recording data Reading out the recorded data Processing the recorded data For an example see samples/datarecorder_gcs30.py . Preliminary Call qREC_STATE to get the current state of a data recorder. Possible states: Configuration ( CFG ): Configuration of the data recorder is only possible in this state. Call REC_STOP to set the data recorder to the configuration state. Waiting ( WAIT ): In this state the data recorder waits for the occurrence of a trigger event which starts the recording. Call REC_START to set the data recorder from the configuration state to the waiting state. Running ( RUN ): In this state the data recorder is recording signals according to the configuration settings. Preparing the data recorder The configuration of data recording consists of the following steps: Setting the record rate Setting the record source and options Setting the trigger event Setting the record rate The Datarecorder property record_rate sets the record rate in number of servo cycles , which is a multiple of the controller-specific servo loop time. Hence the higher the record rate, the slower the data is recorded. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) drec . record_rate = 1 # servo cycles Setting the record source and options The Datarecorder property traces specifies which signal is to be recorded in which trace. The property gets a list of traces to be recorded, each trace with its own specification: Syntax: { <trace id>: [<container unit>, <function_unit>, <parameter>], ... } trace id : Identifier of the trace container unit : Container unit (= element) whose signal is to be recorded function unit : Function unit whose signal is to be recorded parameter : Signal to be recorded in this trace In the example the recording of signals 0x102 (target position) and 0x103 (current position) of AXIS_1 is configured for traces 1 and 2. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . traces = { 1 : [ 'AXIS_1' , '-' , '0x102' ], 2 : [ 'AXIS_1' , '-' , '0x103' ]} Setting the trigger event The Datarecorder property trigger specifies when the recording is to be started, e.g. immediately or with the next command that changes a position . Syntax: [ <trigger name>, <option 1>, <option 2> ] To get a list of trigger names and the corresponding options use the command USG? PROP_ REC_# below the block #Recorder Trigger or #Trigger Option Types (# = identifier of the data recorder, eg. 1) In the example the recording is triggered by the next MOV command on AXIS_1 and is not recurring ( 0 ), i.e. done only once. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . trigger = [ 'MOV' , 'AXIS_1' , '0' ] Recording data Starting the recording The method Datarecorder.arm() arms the data recorder, i.e., enables the actual recording. For this the method performs the following steps: Checks if the data recorder is in configuration state CFG (by querying qREC_STATE ) If necessary, sends REC_STOP to set the data recorder into the configuration state Sends the record rate configuration to the connected device using record_rate Sends the trace configuration to the connected device using traces Sends the trigger configuration to the connected device using trigger Calls REC_START to set the data recorder to the waiting state WAIT In this state it waits until the specified trigger event occurs. After receiving the trigger, the data recorder changes to the running state RUN and starts recording. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . arm () Waiting for the recording to finish To wait for the triggered motion to finish, you can use the \"wait\" helper functions in pipython.pitools , for example waitontarget() . The function halts the application until the triggered motion has finished. It is called with an instance of pidevice and a single or a list of axis identifiers (string or integer). ... pidevice . MOV ([ 'AXIS_1' , 'AXIS_2' ], [ 1.0 , 2.0 ]) pitools . waitontarget ( pidevice , [ 'AXIS_1' , 'AXIS_2' ]) ... Reading out the recorded data Retrieving the data via Datarecorder Recorded data can be read with the Datarecorder properties header and data . The first time you read one of the properties, qREC_DAT is sent to the device, which starts the reading of the data. By default this reads the maximum possible number of data values starting with the first value. To limit the number of data values to be read, you can set the number_of_values property. You can also set the offset property to start the reading not from the first value but with an offset in the trace. In the following example 1,000 data values are read, starting with the 100th value in the trace. This will read the values 100 to 1100 from the trace. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . number_of_values = 1000 # read 1,000 values drec . offset = 100 # start reading with offset 100 data = drec . data # start reading the values and wait until 1000 values have been read Retrieving the data via qREC_DAT Read out the recorded data from the device with qREC_DAT . This function returns immediately with the GCS header containing information on the recorded data. Then it starts a background task which internally buffers the data from the device as it is being transmitted. The status of the internal buffer can be queried with the GCSDevice.bufstate property. It indicates the transmission progress by float values in the range 0...1 and becomes True when the transmission has completed. Hence end a loop with while bufstate is not True and not with while not bufstate . header = pidevice . qREC_DAT ( 'REC_1' , 'ASCII' , [ 1 , 2 ], 100 , 1000 ) while pidevice . bufstate is not True : print ( 'read data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) Warning The background task will lock any communication to the device for the duration of the data transmission. This means that although your application is actually able to continue after having called the qREC_DAT function, any attempt on communication with the device will result in a deadlock. To prevent this always check the GCSDevice.locked property. Processing the recorded data Displaying the data with matplotlib The following example shows how to create a plot using the header and data from a recording that comprises two traces. This requires matplotlib. pyplot . plot ( drec . timescale , drec . data [ 0 ], color = 'red' ) pyplot . plot ( drec . timescale , drec . data [ 1 ], color = 'blue' ) pyplot . xlabel ( 'time (s)' ) pyplot . ylabel ( ', ' . join (( drec . header [ 'NAME0' ], drec . header [ 'NAME1' ]))) pyplot . title ( 'Datarecorder data over time' ) pyplot . grid ( True ) pyplot . show () print ( 'save GCSArray to file \"gcsarray.dat\"' ) pitools . savegcsarray ( 'gcsarray.dat' , drec . header , drec . data ) Converting the data into a NumPy array If you are used to NumPy you can easily convert the recorded data into a NumPy array. import numpy as np ... header , data = drec . getdata () npdata = np . array ( data ) Examples Configure two traces for the same axis and set the MOV trigger The example configures two traces for the same axis, sets the MOV command trigger, and arms the data recorder. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) # Configure the data recorder drec . record_rate = 1 drec . traces = { 1 : [ 'AXIS_1' , '-' , '0x102' ], 2 : [ 'AXIS_1' , '-' , '0x103' ]} drec . trigger = [ 'MOV' , 'AXIS_1' , '0' ] # Trigger on next MOV command on AXIS_1 drec . arm () # Trigger the recording and wait until the motion has finished pidevice . MOV ( 'AXIS_1' , 1.0 ) pitools . waitontarget ( pidevice , 'AXIS_1' ) # Read the recorded values and the header data = drec . data header = drec . header Configure two traces for different axes and set the MOV trigger for one axis The example configures two traces for different axes, sets the MOV command trigger for AXIS_1, and arms the data recorder. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) # Configure the data recorder drec . record_rate = 1 drec . traces = { 1 : [ 'AXIS_1' , '-' , '0x102' ], 2 : [ 'AXIS_2' , '-' , '0x103' ]} drec . trigger = [ 'MOV' , 'AXIS_1' , '0' ] drec . arm () # Trigger the recording and wait until the motion has finished pidevice . MOV ( 'AXIS_1' , 1.0 ) pitools . waitontarget ( pidevice , 'AXIS_1' ) # Read the recorded values and the header data = drec . data header = drec . header Configure two traces for analog inputs, and two for axes and set the NOW trigger The example configures four traces for two analog inputs and two axes, sets the 'NOW' trigger which triggers immediately after starting the data recorder, and arms the data recorder. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) drec . record_rate = 1 drec . traces = { 1 : [ 'CON_1' , 'SENS_1' , '0x1021 ], 2: [ ' CON_2 ', ' SENS_1 ', ' 0x101 ' ] 3 : [ 'AXIS_1' , '-' , '0x102' ], 4 : [ 'AXIS_2' , '-' , '0x103' ]} drec . trigger = [ 'NOW' , '0' , '0' ] drec . arm () # No specific trigger is required, because the data recorder triggers itself # automatically after `REC_START`, which ist called within the `arm()` method. # Read the recorded values and the header data = drec . data header = drec . header","title":"Data Recorder GCS 3.0"},{"location":"datarecorder30.html#data-recorder-gcs-30","text":"Info These instructions are valid for controllers using GCS 3.0. A PI device has one or more record tables that can be filled with data (i.e. values) from a configurable source. PIPython comes with Datarecorder class for the configuration of data recording: pipython.datarectools.Datarecorder . from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... In the further examples on this page, pidevice refers to an instance of pipython.GCSDevice and drec refers to an instance of pipython.datarectools.Datarecorder . The typical workflow for data recording is as follows: Preparing the data recorder Recording data Reading out the recorded data Processing the recorded data For an example see samples/datarecorder_gcs30.py .","title":"Data Recorder GCS 3.0"},{"location":"datarecorder30.html#preliminary","text":"Call qREC_STATE to get the current state of a data recorder. Possible states: Configuration ( CFG ): Configuration of the data recorder is only possible in this state. Call REC_STOP to set the data recorder to the configuration state. Waiting ( WAIT ): In this state the data recorder waits for the occurrence of a trigger event which starts the recording. Call REC_START to set the data recorder from the configuration state to the waiting state. Running ( RUN ): In this state the data recorder is recording signals according to the configuration settings.","title":"Preliminary"},{"location":"datarecorder30.html#preparing-the-data-recorder","text":"The configuration of data recording consists of the following steps: Setting the record rate Setting the record source and options Setting the trigger event","title":"Preparing the data recorder"},{"location":"datarecorder30.html#setting-the-record-rate","text":"The Datarecorder property record_rate sets the record rate in number of servo cycles , which is a multiple of the controller-specific servo loop time. Hence the higher the record rate, the slower the data is recorded. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) drec . record_rate = 1 # servo cycles","title":"Setting the record rate"},{"location":"datarecorder30.html#setting-the-record-source-and-options","text":"The Datarecorder property traces specifies which signal is to be recorded in which trace. The property gets a list of traces to be recorded, each trace with its own specification: Syntax: { <trace id>: [<container unit>, <function_unit>, <parameter>], ... } trace id : Identifier of the trace container unit : Container unit (= element) whose signal is to be recorded function unit : Function unit whose signal is to be recorded parameter : Signal to be recorded in this trace In the example the recording of signals 0x102 (target position) and 0x103 (current position) of AXIS_1 is configured for traces 1 and 2. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . traces = { 1 : [ 'AXIS_1' , '-' , '0x102' ], 2 : [ 'AXIS_1' , '-' , '0x103' ]}","title":"Setting the record source and options"},{"location":"datarecorder30.html#setting-the-trigger-event","text":"The Datarecorder property trigger specifies when the recording is to be started, e.g. immediately or with the next command that changes a position . Syntax: [ <trigger name>, <option 1>, <option 2> ] To get a list of trigger names and the corresponding options use the command USG? PROP_ REC_# below the block #Recorder Trigger or #Trigger Option Types (# = identifier of the data recorder, eg. 1) In the example the recording is triggered by the next MOV command on AXIS_1 and is not recurring ( 0 ), i.e. done only once. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . trigger = [ 'MOV' , 'AXIS_1' , '0' ]","title":"Setting the trigger event"},{"location":"datarecorder30.html#recording-data","text":"","title":"Recording data"},{"location":"datarecorder30.html#starting-the-recording","text":"The method Datarecorder.arm() arms the data recorder, i.e., enables the actual recording. For this the method performs the following steps: Checks if the data recorder is in configuration state CFG (by querying qREC_STATE ) If necessary, sends REC_STOP to set the data recorder into the configuration state Sends the record rate configuration to the connected device using record_rate Sends the trace configuration to the connected device using traces Sends the trigger configuration to the connected device using trigger Calls REC_START to set the data recorder to the waiting state WAIT In this state it waits until the specified trigger event occurs. After receiving the trigger, the data recorder changes to the running state RUN and starts recording. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . arm ()","title":"Starting the recording"},{"location":"datarecorder30.html#waiting-for-the-recording-to-finish","text":"To wait for the triggered motion to finish, you can use the \"wait\" helper functions in pipython.pitools , for example waitontarget() . The function halts the application until the triggered motion has finished. It is called with an instance of pidevice and a single or a list of axis identifiers (string or integer). ... pidevice . MOV ([ 'AXIS_1' , 'AXIS_2' ], [ 1.0 , 2.0 ]) pitools . waitontarget ( pidevice , [ 'AXIS_1' , 'AXIS_2' ]) ...","title":"Waiting for the recording to finish"},{"location":"datarecorder30.html#reading-out-the-recorded-data","text":"","title":"Reading out the recorded data"},{"location":"datarecorder30.html#retrieving-the-data-via-datarecorder","text":"Recorded data can be read with the Datarecorder properties header and data . The first time you read one of the properties, qREC_DAT is sent to the device, which starts the reading of the data. By default this reads the maximum possible number of data values starting with the first value. To limit the number of data values to be read, you can set the number_of_values property. You can also set the offset property to start the reading not from the first value but with an offset in the trace. In the following example 1,000 data values are read, starting with the 100th value in the trace. This will read the values 100 to 1100 from the trace. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) ... drec . number_of_values = 1000 # read 1,000 values drec . offset = 100 # start reading with offset 100 data = drec . data # start reading the values and wait until 1000 values have been read","title":"Retrieving the data via Datarecorder"},{"location":"datarecorder30.html#retrieving-the-data-via-qrec_dat","text":"Read out the recorded data from the device with qREC_DAT . This function returns immediately with the GCS header containing information on the recorded data. Then it starts a background task which internally buffers the data from the device as it is being transmitted. The status of the internal buffer can be queried with the GCSDevice.bufstate property. It indicates the transmission progress by float values in the range 0...1 and becomes True when the transmission has completed. Hence end a loop with while bufstate is not True and not with while not bufstate . header = pidevice . qREC_DAT ( 'REC_1' , 'ASCII' , [ 1 , 2 ], 100 , 1000 ) while pidevice . bufstate is not True : print ( 'read data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) Warning The background task will lock any communication to the device for the duration of the data transmission. This means that although your application is actually able to continue after having called the qREC_DAT function, any attempt on communication with the device will result in a deadlock. To prevent this always check the GCSDevice.locked property.","title":"Retrieving the data via qREC_DAT"},{"location":"datarecorder30.html#processing-the-recorded-data","text":"","title":"Processing the recorded data"},{"location":"datarecorder30.html#displaying-the-data-with-matplotlib","text":"The following example shows how to create a plot using the header and data from a recording that comprises two traces. This requires matplotlib. pyplot . plot ( drec . timescale , drec . data [ 0 ], color = 'red' ) pyplot . plot ( drec . timescale , drec . data [ 1 ], color = 'blue' ) pyplot . xlabel ( 'time (s)' ) pyplot . ylabel ( ', ' . join (( drec . header [ 'NAME0' ], drec . header [ 'NAME1' ]))) pyplot . title ( 'Datarecorder data over time' ) pyplot . grid ( True ) pyplot . show () print ( 'save GCSArray to file \"gcsarray.dat\"' ) pitools . savegcsarray ( 'gcsarray.dat' , drec . header , drec . data )","title":"Displaying the data with matplotlib"},{"location":"datarecorder30.html#converting-the-data-into-a-numpy-array","text":"If you are used to NumPy you can easily convert the recorded data into a NumPy array. import numpy as np ... header , data = drec . getdata () npdata = np . array ( data )","title":"Converting the data into a NumPy array"},{"location":"datarecorder30.html#examples","text":"Configure two traces for the same axis and set the MOV trigger The example configures two traces for the same axis, sets the MOV command trigger, and arms the data recorder. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) # Configure the data recorder drec . record_rate = 1 drec . traces = { 1 : [ 'AXIS_1' , '-' , '0x102' ], 2 : [ 'AXIS_1' , '-' , '0x103' ]} drec . trigger = [ 'MOV' , 'AXIS_1' , '0' ] # Trigger on next MOV command on AXIS_1 drec . arm () # Trigger the recording and wait until the motion has finished pidevice . MOV ( 'AXIS_1' , 1.0 ) pitools . waitontarget ( pidevice , 'AXIS_1' ) # Read the recorded values and the header data = drec . data header = drec . header Configure two traces for different axes and set the MOV trigger for one axis The example configures two traces for different axes, sets the MOV command trigger for AXIS_1, and arms the data recorder. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) # Configure the data recorder drec . record_rate = 1 drec . traces = { 1 : [ 'AXIS_1' , '-' , '0x102' ], 2 : [ 'AXIS_2' , '-' , '0x103' ]} drec . trigger = [ 'MOV' , 'AXIS_1' , '0' ] drec . arm () # Trigger the recording and wait until the motion has finished pidevice . MOV ( 'AXIS_1' , 1.0 ) pitools . waitontarget ( pidevice , 'AXIS_1' ) # Read the recorded values and the header data = drec . data header = drec . header Configure two traces for analog inputs, and two for axes and set the NOW trigger The example configures four traces for two analog inputs and two axes, sets the 'NOW' trigger which triggers immediately after starting the data recorder, and arms the data recorder. from pipython import GCSDevice from pipython import datarectools , pitools pidevice = GCSDevice () pidevice . InterfaceSetupDlg () ... drec = datarectools . Datarecorder ( pidevice ) drec . record_rate = 1 drec . traces = { 1 : [ 'CON_1' , 'SENS_1' , '0x1021 ], 2: [ ' CON_2 ', ' SENS_1 ', ' 0x101 ' ] 3 : [ 'AXIS_1' , '-' , '0x102' ], 4 : [ 'AXIS_2' , '-' , '0x103' ]} drec . trigger = [ 'NOW' , '0' , '0' ] drec . arm () # No specific trigger is required, because the data recorder triggers itself # automatically after `REC_START`, which ist called within the `arm()` method. # Read the recorded values and the header data = drec . data header = drec . header","title":"Examples"},{"location":"eula.html","text":"License Agreement General Software License Agreement of Physik Instrumente (PI) GmbH & Co. KG Issued: April 16, 2018 Preamble Physik Instrumente (PI) GmbH & Co. KG (hereinafter referred to as \"PI\") is a manufacturer and provider of micro- and nanopositioning technology and motion control systems, devices and apparatuses including their respective firmware (hereinafter jointly referred to as \"the PI Hardware\"), which can either be used independently or as an integral part of other third-party hardware systems. For the purpose of operating the PI Hardware, PI provides its customers, which either purchase the PI Hardware directly from PI for their own use or which integrate the PI Hardware into third-party hardware systems for distribution to their clients (hereinafter jointly referred to as \"the Customer\") with software products or tools (hereinafter jointly referred to as \"the Software\"). The following general terms and conditions (hereinafter referred to as \"Terms and Conditions\") shall apply to any Software provided by PI to the Customer, unless expressly agreed or stated otherwise herein, and may be supplemented by specific terms and conditions for individual software components. I. Scope (1) These Terms and Conditions shall apply to the supply of Software for its use together with PI Hardware and the granting of rights of use to the Customer, as described below. (2) The Software is supplied by PI to the Customer either in machine-readable form or with regard to certain software components in machine-readable form together with its source code and is subject to the following Terms and Conditions, unless PI and the Customer have agreed otherwise in writing. (3) These Terms and Conditions shall not apply to the PI Hardware. (4) PI does not owe any installation and configuration services under these Terms and Conditions. (5) The Software is not designed for use in medical devices (Medizinprodukt) according to section 3 of the German Act on Medical Devices (MPG). (6) References to the application of statutory provisions only serve clarification purposes. Therefore, the statutory provisions apply even without such clarification, unless modified directly by these Terms and Conditions. II. Rights of Use (1) Unless stated otherwise herein, PI grants to the Customer a non-exclusive territorially unrestricted right to use the Software for an unlimited period of time on the basis of the following provisions. (2) The following restrictions apply, if not explicitly agreed otherwise: (i) The Customer shall be entitled to use the Software insofar as this is required for the contractually agreed or contractually intended use of the Software and in accordance with these Terms and Conditions, including the right to install the Software onto a hard disk drive and/or to load it into the random access memory (RAM). If not specified otherwise, the Customer is entitled to use the Software within its company on several devices or on several workstations simultaneously and to duplicate the Software for that purpose. In the event that the use of the Software depends on a prior activation and is therefore limited to a certain license key (to be individually purchased by the Customer from PI), the use of the affected Software shall however be restricted to the respective device for which the Software has been activated by the Customer. The Software shall in any case be used by the Customer exclusively for and in relation with the operation of PI Hardware. The Customer shall insofar however be entitled to use the Software together with third-party software or to combine the Software with third-party software products, as far as necessary to operate its or any third-party systems that do include the PI Hardware. (ii) The Customer shall furthermore be entitled to generate application-specific, loadable and executable software products with the Software and to transfer such software products to third parties only for use for and in relation with the operation of PI Hardware. Such third party shall not be granted any rights of use beyond the rights of use granted to Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party shall be bound by the contractual obligations under these Terms and Conditions with regard to the software products. (iii) The Customer shall be entitled to transfer the right of use granted hereunder to a third party, provided that such third party agrees to the continued validity of the rights of use for and in relation with the PI Hardware and that the Customer deletes any remaining copies of the Software without undue delay. Such a third party shall not be granted any rights of use beyond the rights of use granted to the Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party uses the Software in accordance with these Terms and Conditions and in particular solely for the purpose of operating the PI Hardware. Subparagraph (xii) shall remain unaffected. (iv) The subleasing of the Software for commercial purposes is prohibited. (v) The Customer shall not grant any sublicenses of the Software, unless stipulated otherwise in these Terms and Conditions. (vi) The Customer shall not be entitled to modify, extend, reverse engineer, decompile, reverse assemble or disassemble Software delivered in machine-readable form (object code) unless it is necessary for the purpose of using the Software in accordance with its contractually agreed or contractually intended purpose, including the purpose of removing defects, or unless it is specifically permitted by law, particularly according to section 69a et sqq. of the German Copyright Act (UrhG), in any case only if PI does not provide the Customer with the required information or does not remove the defect within a reasonable period of time after having been requested to do so via an email sent by the Customer to service@pi.de. (vii) If the Software or parts thereof are provided together with its source code, the Customer shall be entitled to modify the Software on the basis of the source code and to use the modified source code solely for the purpose of operating the PI Hardware and/or third-party systems that include the PI Hardware in accordance with these Terms and Conditions; provided, however, that the Customer shall always include in any such modification a brief summary of the changes made to the source code and the date of the modification. Subject to clause IV, PI shall not be held responsible for any claims resulting from such modification of the source code. (viii) Copyright notes, serial numbers as well as further characteristics for identification shall not be removed from the Software and copies thereof. (ix) PI may provide the Customer with Software which includes or may be used together with third-party software (including freeware and open source software components). PI informs the Customer about the third-party software used and provides the Customer with the corresponding license terms within the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf) to the extent requested by the respective licensor. With regard to third-party software listed in the Third Party Software Note, the respective license terms, which the third-party software is subject to, shall apply. In case of a breach of the third-party license terms, the respective licensor may also be entitled to make subsequent claims and rights in its own name. (x) If PI provides the Customer with amendments (patches, bug fixes, amendments to the manual etc.) or a new edition (updates, upgrades) of the Software within the scope of rectification or maintenance, which replace the originally provided Software, those are subject to these Terms and Conditions. (xi) In the event that PI provides the Customer with a test version of the Software, these Terms and Conditions apply accordingly, however, except that the Customer is granted with a right to use the Software, which is limited to the defined test period. (xii) A temporary use of the Software by a third person, who integrates the Software and PI Hardware with other products on behalf of the Customer, is considered as use by the Customer's company. Such third party shall use the Software only within the time period required for the integration or for providing support services to the Customer and shall be bound in accordance with the contractual obligations under these Terms and Conditions. III. Rectification in case of defects (1) Definitions (i) The Software shall be deemed as defective in quality in the event that it does not show the contractually stipulated condition or it does not fit the contractually stipulated purpose. (ii) The Software is subject to proprietary rights (particularly copyrights) of PI and/or third parties. It constitutes a defect in title if required rights for the contract-based usage could not be legally granted to the Customer. (2) Statute of limitations (i) The statute of limitations for claims of defects is 12 months, calculated from the date of the delivery of the Software. (ii) This does not apply in the event of actions of PI or its representatives or vicarious agents (Erfuellungsgehilfen) in bad faith or in relation to guarantees granted. (3) Modifications to the Software by the Customer As far as the Customer modifies the Software or has it modified by third parties, claims regarding defects in quality or title shall be invalidated, unless the Customer proofs that the defect was not caused by the modifications and also if the analysis and the removal of the defect is not affected by the modification. (4) Obligations to examine and notify defects (i) After delivery of the Software to the Customer, the Customer shall examine the Software for completeness and possible defects without undue delay, insofar as this is feasible in the orderly course of business, and notify PI immediately of any complaints. Otherwise, claims of the Customer as defined in the following clauses shall be excluded in relation to such defects in quality that would have been obvious within a properly conducted examination. (ii) Together with the notification of the defect, the Customer has to provide PI with comprehensible documentation thereof. (5) Supplementary performance (Nacherfuellung) (i) PI may rectify the defect by reworking the Software (Nachbesserung) or by supplying a replacement, as it chooses. The Customer may request within a reasonable time period a reworking or a supply of a replacement of the Software, if another type of supplementary performance is unreasonable. (ii) Alternatively, PI can rectify the defect by providing instructions electronically, by phone, in writing or by providing updates for download on its homepage to the Customer. (6) Measures in the event of alleged defects in title (i) Should a third party raise claims against the Customer based on the allegation that the Software or the designation of the Software infringes its intellectual property rights, the Customer will notify PI immediately thereof and entrust PI with the defense against the alleged claims as far as possible. The Customer will provide to PI any reasonable support in this regard. (ii) PI can remedy a defect in title by providing the Customer with a legally unchallengeable option to use either the Software or a legally unchallengeable modification of the Software, at its sole discretion. If not stipulated otherwise, the regulations of this clause also remain applicable equivalently in relations to defects in title. (7) PI shall provide its services subject to the supplementary performance within a reasonable period. (8) Bad faith (Arglist), guarantees Statutory claims of the Customer remain unaffected in case of actions of PI or its representatives or vicarious agents in bad faith or in relation to guarantees granted. The stipulations of clause IV shall remain unaffected by this clause III. IV. Limitation of Liability PI only assumes liability under the following conditions: (1) For damage caused by PI or any of its legal representatives, executive staff or vicarious agents through willful intent or gross negligence, PI is liable without restriction. (2) PI is not liable for any violation of insignificant contractual obligations by minor negligence. With regard to a violation of essential contractual obligations (i.e. obligations which the contractual partner can expect to be fulfilled and the fulfilment of which is required for the due execution of the contract) PI's liability for damage caused by minor negligence is limited to anticipated damage typical to contracts of this kind (vertragstypisch vorhersehbare Schaeden). The same applies to violations of obligations through minor negligence committed by legal representatives, executive staff or vicarious agents of PI. (3) No license fee is charged to the Customer by PI for the use of any open source or freeware software component / product. Regarding such components / products, the Customer hereby accepts the application of the corresponding license terms which are attached in the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf). To the extent that there is a conflict between these Terms and Conditions and the respective license terms, the license terms shall prevail over these Terms and Conditions with regard to the respective open source or freeware software component / product. However, PI's liability for willful intent and gross negligence remains unaffected. (4) Notwithstanding the foregoing, contributory negligence of the Client diminishes the amount of any claims for damages, especially if caused by insufficient cooperation, organizational errors, insufficient data protection or a breach of other contractual duties. (5) The Customer is responsible to back up his data regularly. In the event of a loss of data caused by PI, the liability of PI is limited to the costs of reproducing the lost data on the basis of the backups that the Customer was under the obligation to conduct and for costs for reproducing data that would have been also lost, even if the Customer had conducted regular backups. (6) The aforementioned limitation of liability does not apply in the event of fraudulent intent, injury to life, body and health, breach of warranty, and claims based on the German Product Liability Act (ProduktHaftG). V. Final Provisions (1) The place of performance for deliveries shall be the registered office (Sitz) of PI. (2) The district court of Karlsruhe (Landgericht Karlsruhe) shall have jurisdiction over all disputes arising from or in connection with these Terms and Conditions. PI shall, however, be entitled to assert claims at the registered seat of the Customer. (3) The laws of Germany shall apply. International purchase laws shall not apply. This shall, in particular, refer to the UN Convention (CISG) on the International Sale of Goods. (4) The invalidity or unenforceability of any provision of these Terms and Conditions shall not affect the validity and enforceability of the other provisions. Invalid or unenforceable provisions shall be deemed to be replaced by such valid and enforceable provisions that shall be suitable to implement the economic purpose of the deleted provision to the greatest extent possible. The same applies for omissions.","title":"EULA"},{"location":"eula.html#license-agreement","text":"General Software License Agreement of Physik Instrumente (PI) GmbH & Co. KG Issued: April 16, 2018","title":"License Agreement"},{"location":"eula.html#preamble","text":"Physik Instrumente (PI) GmbH & Co. KG (hereinafter referred to as \"PI\") is a manufacturer and provider of micro- and nanopositioning technology and motion control systems, devices and apparatuses including their respective firmware (hereinafter jointly referred to as \"the PI Hardware\"), which can either be used independently or as an integral part of other third-party hardware systems. For the purpose of operating the PI Hardware, PI provides its customers, which either purchase the PI Hardware directly from PI for their own use or which integrate the PI Hardware into third-party hardware systems for distribution to their clients (hereinafter jointly referred to as \"the Customer\") with software products or tools (hereinafter jointly referred to as \"the Software\"). The following general terms and conditions (hereinafter referred to as \"Terms and Conditions\") shall apply to any Software provided by PI to the Customer, unless expressly agreed or stated otherwise herein, and may be supplemented by specific terms and conditions for individual software components.","title":"Preamble"},{"location":"eula.html#i-scope","text":"(1) These Terms and Conditions shall apply to the supply of Software for its use together with PI Hardware and the granting of rights of use to the Customer, as described below. (2) The Software is supplied by PI to the Customer either in machine-readable form or with regard to certain software components in machine-readable form together with its source code and is subject to the following Terms and Conditions, unless PI and the Customer have agreed otherwise in writing. (3) These Terms and Conditions shall not apply to the PI Hardware. (4) PI does not owe any installation and configuration services under these Terms and Conditions. (5) The Software is not designed for use in medical devices (Medizinprodukt) according to section 3 of the German Act on Medical Devices (MPG). (6) References to the application of statutory provisions only serve clarification purposes. Therefore, the statutory provisions apply even without such clarification, unless modified directly by these Terms and Conditions.","title":"I. Scope"},{"location":"eula.html#ii-rights-of-use","text":"(1) Unless stated otherwise herein, PI grants to the Customer a non-exclusive territorially unrestricted right to use the Software for an unlimited period of time on the basis of the following provisions. (2) The following restrictions apply, if not explicitly agreed otherwise: (i) The Customer shall be entitled to use the Software insofar as this is required for the contractually agreed or contractually intended use of the Software and in accordance with these Terms and Conditions, including the right to install the Software onto a hard disk drive and/or to load it into the random access memory (RAM). If not specified otherwise, the Customer is entitled to use the Software within its company on several devices or on several workstations simultaneously and to duplicate the Software for that purpose. In the event that the use of the Software depends on a prior activation and is therefore limited to a certain license key (to be individually purchased by the Customer from PI), the use of the affected Software shall however be restricted to the respective device for which the Software has been activated by the Customer. The Software shall in any case be used by the Customer exclusively for and in relation with the operation of PI Hardware. The Customer shall insofar however be entitled to use the Software together with third-party software or to combine the Software with third-party software products, as far as necessary to operate its or any third-party systems that do include the PI Hardware. (ii) The Customer shall furthermore be entitled to generate application-specific, loadable and executable software products with the Software and to transfer such software products to third parties only for use for and in relation with the operation of PI Hardware. Such third party shall not be granted any rights of use beyond the rights of use granted to Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party shall be bound by the contractual obligations under these Terms and Conditions with regard to the software products. (iii) The Customer shall be entitled to transfer the right of use granted hereunder to a third party, provided that such third party agrees to the continued validity of the rights of use for and in relation with the PI Hardware and that the Customer deletes any remaining copies of the Software without undue delay. Such a third party shall not be granted any rights of use beyond the rights of use granted to the Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party uses the Software in accordance with these Terms and Conditions and in particular solely for the purpose of operating the PI Hardware. Subparagraph (xii) shall remain unaffected. (iv) The subleasing of the Software for commercial purposes is prohibited. (v) The Customer shall not grant any sublicenses of the Software, unless stipulated otherwise in these Terms and Conditions. (vi) The Customer shall not be entitled to modify, extend, reverse engineer, decompile, reverse assemble or disassemble Software delivered in machine-readable form (object code) unless it is necessary for the purpose of using the Software in accordance with its contractually agreed or contractually intended purpose, including the purpose of removing defects, or unless it is specifically permitted by law, particularly according to section 69a et sqq. of the German Copyright Act (UrhG), in any case only if PI does not provide the Customer with the required information or does not remove the defect within a reasonable period of time after having been requested to do so via an email sent by the Customer to service@pi.de. (vii) If the Software or parts thereof are provided together with its source code, the Customer shall be entitled to modify the Software on the basis of the source code and to use the modified source code solely for the purpose of operating the PI Hardware and/or third-party systems that include the PI Hardware in accordance with these Terms and Conditions; provided, however, that the Customer shall always include in any such modification a brief summary of the changes made to the source code and the date of the modification. Subject to clause IV, PI shall not be held responsible for any claims resulting from such modification of the source code. (viii) Copyright notes, serial numbers as well as further characteristics for identification shall not be removed from the Software and copies thereof. (ix) PI may provide the Customer with Software which includes or may be used together with third-party software (including freeware and open source software components). PI informs the Customer about the third-party software used and provides the Customer with the corresponding license terms within the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf) to the extent requested by the respective licensor. With regard to third-party software listed in the Third Party Software Note, the respective license terms, which the third-party software is subject to, shall apply. In case of a breach of the third-party license terms, the respective licensor may also be entitled to make subsequent claims and rights in its own name. (x) If PI provides the Customer with amendments (patches, bug fixes, amendments to the manual etc.) or a new edition (updates, upgrades) of the Software within the scope of rectification or maintenance, which replace the originally provided Software, those are subject to these Terms and Conditions. (xi) In the event that PI provides the Customer with a test version of the Software, these Terms and Conditions apply accordingly, however, except that the Customer is granted with a right to use the Software, which is limited to the defined test period. (xii) A temporary use of the Software by a third person, who integrates the Software and PI Hardware with other products on behalf of the Customer, is considered as use by the Customer's company. Such third party shall use the Software only within the time period required for the integration or for providing support services to the Customer and shall be bound in accordance with the contractual obligations under these Terms and Conditions.","title":"II. Rights of Use"},{"location":"eula.html#iii-rectification-in-case-of-defects","text":"(1) Definitions (i) The Software shall be deemed as defective in quality in the event that it does not show the contractually stipulated condition or it does not fit the contractually stipulated purpose. (ii) The Software is subject to proprietary rights (particularly copyrights) of PI and/or third parties. It constitutes a defect in title if required rights for the contract-based usage could not be legally granted to the Customer. (2) Statute of limitations (i) The statute of limitations for claims of defects is 12 months, calculated from the date of the delivery of the Software. (ii) This does not apply in the event of actions of PI or its representatives or vicarious agents (Erfuellungsgehilfen) in bad faith or in relation to guarantees granted. (3) Modifications to the Software by the Customer As far as the Customer modifies the Software or has it modified by third parties, claims regarding defects in quality or title shall be invalidated, unless the Customer proofs that the defect was not caused by the modifications and also if the analysis and the removal of the defect is not affected by the modification. (4) Obligations to examine and notify defects (i) After delivery of the Software to the Customer, the Customer shall examine the Software for completeness and possible defects without undue delay, insofar as this is feasible in the orderly course of business, and notify PI immediately of any complaints. Otherwise, claims of the Customer as defined in the following clauses shall be excluded in relation to such defects in quality that would have been obvious within a properly conducted examination. (ii) Together with the notification of the defect, the Customer has to provide PI with comprehensible documentation thereof. (5) Supplementary performance (Nacherfuellung) (i) PI may rectify the defect by reworking the Software (Nachbesserung) or by supplying a replacement, as it chooses. The Customer may request within a reasonable time period a reworking or a supply of a replacement of the Software, if another type of supplementary performance is unreasonable. (ii) Alternatively, PI can rectify the defect by providing instructions electronically, by phone, in writing or by providing updates for download on its homepage to the Customer. (6) Measures in the event of alleged defects in title (i) Should a third party raise claims against the Customer based on the allegation that the Software or the designation of the Software infringes its intellectual property rights, the Customer will notify PI immediately thereof and entrust PI with the defense against the alleged claims as far as possible. The Customer will provide to PI any reasonable support in this regard. (ii) PI can remedy a defect in title by providing the Customer with a legally unchallengeable option to use either the Software or a legally unchallengeable modification of the Software, at its sole discretion. If not stipulated otherwise, the regulations of this clause also remain applicable equivalently in relations to defects in title. (7) PI shall provide its services subject to the supplementary performance within a reasonable period. (8) Bad faith (Arglist), guarantees Statutory claims of the Customer remain unaffected in case of actions of PI or its representatives or vicarious agents in bad faith or in relation to guarantees granted. The stipulations of clause IV shall remain unaffected by this clause III.","title":"III. Rectification in case of defects"},{"location":"eula.html#iv-limitation-of-liability","text":"PI only assumes liability under the following conditions: (1) For damage caused by PI or any of its legal representatives, executive staff or vicarious agents through willful intent or gross negligence, PI is liable without restriction. (2) PI is not liable for any violation of insignificant contractual obligations by minor negligence. With regard to a violation of essential contractual obligations (i.e. obligations which the contractual partner can expect to be fulfilled and the fulfilment of which is required for the due execution of the contract) PI's liability for damage caused by minor negligence is limited to anticipated damage typical to contracts of this kind (vertragstypisch vorhersehbare Schaeden). The same applies to violations of obligations through minor negligence committed by legal representatives, executive staff or vicarious agents of PI. (3) No license fee is charged to the Customer by PI for the use of any open source or freeware software component / product. Regarding such components / products, the Customer hereby accepts the application of the corresponding license terms which are attached in the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf). To the extent that there is a conflict between these Terms and Conditions and the respective license terms, the license terms shall prevail over these Terms and Conditions with regard to the respective open source or freeware software component / product. However, PI's liability for willful intent and gross negligence remains unaffected. (4) Notwithstanding the foregoing, contributory negligence of the Client diminishes the amount of any claims for damages, especially if caused by insufficient cooperation, organizational errors, insufficient data protection or a breach of other contractual duties. (5) The Customer is responsible to back up his data regularly. In the event of a loss of data caused by PI, the liability of PI is limited to the costs of reproducing the lost data on the basis of the backups that the Customer was under the obligation to conduct and for costs for reproducing data that would have been also lost, even if the Customer had conducted regular backups. (6) The aforementioned limitation of liability does not apply in the event of fraudulent intent, injury to life, body and health, breach of warranty, and claims based on the German Product Liability Act (ProduktHaftG).","title":"IV. Limitation of Liability"},{"location":"eula.html#v-final-provisions","text":"(1) The place of performance for deliveries shall be the registered office (Sitz) of PI. (2) The district court of Karlsruhe (Landgericht Karlsruhe) shall have jurisdiction over all disputes arising from or in connection with these Terms and Conditions. PI shall, however, be entitled to assert claims at the registered seat of the Customer. (3) The laws of Germany shall apply. International purchase laws shall not apply. This shall, in particular, refer to the UN Convention (CISG) on the International Sale of Goods. (4) The invalidity or unenforceability of any provision of these Terms and Conditions shall not affect the validity and enforceability of the other provisions. Invalid or unenforceable provisions shall be deemed to be replaced by such valid and enforceable provisions that shall be suitable to implement the economic purpose of the deleted provision to the greatest extent possible. The same applies for omissions.","title":"V. Final Provisions"},{"location":"history.html","text":"Feature Version History PIPython 2.10.0 add GCSCommands.STF() add new status bits returned by GCSCommands.STV(). PIPython 2.9.0 add support for open loop control mode in pitools fix bug in simplemove sample. PIPython 2.8.0 add pitools.getmaxtravelrange() add pitools.getmintravelrange() PIPython 2.7.0 add GCSCommands.qIPR() add GCSCommands.RES() add PILogger PIPython 2.6.0 add support for GCS 3.0 controllers add data recorder tools for controllers with GCS 3.0 syntax PIPython 2.5.1 fix missing files in pitools PIPython 2.5.0 Support for GCS30 UMF Controllers PIPython 2.4.0 add GCSCommands.qUSG() add GCSCommands.SPV() add GCSCommands.qSPV() add GCSCommands.CPA() add GCSCommands.UCL() add GCSCommands.qUCL() add GCSCommands.REC_STAT() add GCSCommands.qREC_STAT() add GCSCommands.REC_TRACE() add GCSCommands.qREC_TRACE() add GCSCommands.REC_TRG() add GCSCommands.qREC_TRG() add GCSCommands.REC_RATE() add GCSCommands.qREC_RATE() add GCSCommands.REC_START() add GCSCommands.REC_STOP() add GCSCommands.qREC_NUM() add GCSCommands.qREC_DAT() add GCSCommands.qLOG() PIPython 2.3.0 Internal refactoring PIPython 2.2.2 fix: No module named gcs30.gcs30commands_helpers PIPython 2.2.1 fix missing argument in isgcs30 PIPython 2.2.0 Support for PI_SetConnectTimeout() and PI_EnableBaudRateScan() PIPython 2.1.1 fix timing probles while reading the data recorder with pythom3 PIPython 2.1.0 pipython.datarectools.Datarecorder: maxnumvalues now also reads the maximum number of data recorder points from the 'HDR?' answer. fix pipython.pitools.pitoopls.itemstostr. If 'data' is an integer of 0 or a float of 0.0 'itemstostr' now returns the string '0' or '0.0' instead of 'None' PIPython 2.0.0 New package structure support for WriteConfigurationFromDatabaseToControllerAndSave() PIPython 1.5.2 Linux: fix string decoding in piusb PIPython 1.5.1 fix parameter value conversion of hex parameter values PIPython 1.5.0 add GCSCommands.POL() add GCSCommands.STD() add GCSCommands.RTD() add GCSCommands.qRTD() add GCSCommands.qLST() add GCSCommands.DTL() PIPython 1.4.0 fix string decoding in GCSDll() add pitools.getservo() pitools.waitonreferencing() does not call waitontarget() in pitools call waitonready() with the \"polldelay\" argument fix signature of GCSCommands.qTWS() GCSCommands.CCL() will reset the list of supported GCS commands interfaces.pisocket.PISocket() uses socket.TCP_NODELAY add \"ATZ\" as \"referencing command\" to pitools.DeviceStartup() add GCSMessages.logfile property rename license.md to eula.md add datarectools.get_hdr_options() add Datarecorder.recopts property add Datarecorder.trigopts property all timeout default values are set to 300 seconds PIPython 1.3.9 add pitools.waitonmacro() catch GCS error 2 (unknown command) after EAX during startup GCS commands arguments can be sets, too DDL(tables, offsets, values) -> DDL(table, offsets, values) add GCSDevice.isavailable convert parameter values according to types in qHPA answer fix signature of GCSCommands.qJLT() PIPython 1.3.8 add interfaces.piusb add pitools.readgcsarray() add pitools.waitonwavegen() add pitools.moveandwait() add piparams.applyconfig() pitools.startup() defines and references stages only if necessary add GCSCommands.allaxes add GCSDevice.hasref() add GCSDevice.haslim() add GCSDevice.canfrf() add GCSDevice.canfnl() add GCSDevice.canfpl() add pitools.waitonphase() add pitools.setservo() controller specific startup sequence PIPython 1.3.7 add pitools.movetomiddle() add pipython.fastaligntools PI_GCS2_DLL is used by default add pitools.savegcsarray() add pitools.itemstostr() PIPython 1.3.6 add controller C-886, E-872 GCSDevice supports external Gateway PIPython 1.3.5 add DLL functions for PIStages3 \"wait on\" functions support polldelay times fix GCSCommands.SGA() fix GCSCommands.qSPA() fix GCSCommands.qSEP() add optional argument \"noraise\" for StopAll(), HLT(), STP() add pitools.waitonfastalign() add pitools.waitonautozero() add GCS Error codes PIPython 1.3.4 add pipython.interfaces.piserial \"wait on\" functions support predelay and postdelay times add GCSCommands.TSP() setup writes key for PIUpdateFinder always into 32 bit part of registry change formatting of numbers in GCS strings GCSDll supports \"K\" devices GCSMessages.bufstate will not write to log rename ReadGCSData() -> read_gcsdata() add controller C-663.12 add parameters for E-873.3QTU, C-663.10C885 add GCS Error codes bugfixing PIPython 1.3.3 add GCSCommands.SGP() add GCSCommands.qSGP() add GCSCommands.WAV_SIN() add GCSCommands.WAV_POL() add GCSCommands.WAV_TAN() add GCSCommands.WAV_SWEEP() add GCSCommands.checkerror() add GCSCommands.DEL() add new controllers add controller parameters fix for handling unicode in Python 3 bugfixing of some GCS commands PIPython 1.3.2 add GCSCommands.FSF() add GCSCommands.qFSF() add GCSCommands.qFSR() add pitools.getaxeslist() add pitools.ontarget() add pitools.waitonwalk() add pitools.waitonoma() add pitools.waitontrajectory() fix DLL function prefix","title":"History"},{"location":"history.html#feature-version-history","text":"","title":"Feature Version History"},{"location":"history.html#pipython-2100","text":"add GCSCommands.STF() add new status bits returned by GCSCommands.STV().","title":"PIPython 2.10.0"},{"location":"history.html#pipython-290","text":"add support for open loop control mode in pitools fix bug in simplemove sample.","title":"PIPython 2.9.0"},{"location":"history.html#pipython-280","text":"add pitools.getmaxtravelrange() add pitools.getmintravelrange()","title":"PIPython 2.8.0"},{"location":"history.html#pipython-270","text":"add GCSCommands.qIPR() add GCSCommands.RES() add PILogger","title":"PIPython 2.7.0"},{"location":"history.html#pipython-260","text":"add support for GCS 3.0 controllers add data recorder tools for controllers with GCS 3.0 syntax","title":"PIPython 2.6.0"},{"location":"history.html#pipython-251","text":"fix missing files in pitools","title":"PIPython 2.5.1"},{"location":"history.html#pipython-250","text":"Support for GCS30 UMF Controllers","title":"PIPython 2.5.0"},{"location":"history.html#pipython-240","text":"add GCSCommands.qUSG() add GCSCommands.SPV() add GCSCommands.qSPV() add GCSCommands.CPA() add GCSCommands.UCL() add GCSCommands.qUCL() add GCSCommands.REC_STAT() add GCSCommands.qREC_STAT() add GCSCommands.REC_TRACE() add GCSCommands.qREC_TRACE() add GCSCommands.REC_TRG() add GCSCommands.qREC_TRG() add GCSCommands.REC_RATE() add GCSCommands.qREC_RATE() add GCSCommands.REC_START() add GCSCommands.REC_STOP() add GCSCommands.qREC_NUM() add GCSCommands.qREC_DAT() add GCSCommands.qLOG()","title":"PIPython 2.4.0"},{"location":"history.html#pipython-230","text":"Internal refactoring","title":"PIPython 2.3.0"},{"location":"history.html#pipython-222","text":"fix: No module named gcs30.gcs30commands_helpers","title":"PIPython 2.2.2"},{"location":"history.html#pipython-221","text":"fix missing argument in isgcs30","title":"PIPython 2.2.1"},{"location":"history.html#pipython-220","text":"Support for PI_SetConnectTimeout() and PI_EnableBaudRateScan()","title":"PIPython 2.2.0"},{"location":"history.html#pipython-211","text":"fix timing probles while reading the data recorder with pythom3","title":"PIPython 2.1.1"},{"location":"history.html#pipython-210","text":"pipython.datarectools.Datarecorder: maxnumvalues now also reads the maximum number of data recorder points from the 'HDR?' answer. fix pipython.pitools.pitoopls.itemstostr. If 'data' is an integer of 0 or a float of 0.0 'itemstostr' now returns the string '0' or '0.0' instead of 'None'","title":"PIPython 2.1.0"},{"location":"history.html#pipython-200","text":"New package structure support for WriteConfigurationFromDatabaseToControllerAndSave()","title":"PIPython 2.0.0"},{"location":"history.html#pipython-152","text":"Linux: fix string decoding in piusb","title":"PIPython 1.5.2"},{"location":"history.html#pipython-151","text":"fix parameter value conversion of hex parameter values","title":"PIPython 1.5.1"},{"location":"history.html#pipython-150","text":"add GCSCommands.POL() add GCSCommands.STD() add GCSCommands.RTD() add GCSCommands.qRTD() add GCSCommands.qLST() add GCSCommands.DTL()","title":"PIPython 1.5.0"},{"location":"history.html#pipython-140","text":"fix string decoding in GCSDll() add pitools.getservo() pitools.waitonreferencing() does not call waitontarget() in pitools call waitonready() with the \"polldelay\" argument fix signature of GCSCommands.qTWS() GCSCommands.CCL() will reset the list of supported GCS commands interfaces.pisocket.PISocket() uses socket.TCP_NODELAY add \"ATZ\" as \"referencing command\" to pitools.DeviceStartup() add GCSMessages.logfile property rename license.md to eula.md add datarectools.get_hdr_options() add Datarecorder.recopts property add Datarecorder.trigopts property all timeout default values are set to 300 seconds","title":"PIPython 1.4.0"},{"location":"history.html#pipython-139","text":"add pitools.waitonmacro() catch GCS error 2 (unknown command) after EAX during startup GCS commands arguments can be sets, too DDL(tables, offsets, values) -> DDL(table, offsets, values) add GCSDevice.isavailable convert parameter values according to types in qHPA answer fix signature of GCSCommands.qJLT()","title":"PIPython 1.3.9"},{"location":"history.html#pipython-138","text":"add interfaces.piusb add pitools.readgcsarray() add pitools.waitonwavegen() add pitools.moveandwait() add piparams.applyconfig() pitools.startup() defines and references stages only if necessary add GCSCommands.allaxes add GCSDevice.hasref() add GCSDevice.haslim() add GCSDevice.canfrf() add GCSDevice.canfnl() add GCSDevice.canfpl() add pitools.waitonphase() add pitools.setservo() controller specific startup sequence","title":"PIPython 1.3.8"},{"location":"history.html#pipython-137","text":"add pitools.movetomiddle() add pipython.fastaligntools PI_GCS2_DLL is used by default add pitools.savegcsarray() add pitools.itemstostr()","title":"PIPython 1.3.7"},{"location":"history.html#pipython-136","text":"add controller C-886, E-872 GCSDevice supports external Gateway","title":"PIPython 1.3.6"},{"location":"history.html#pipython-135","text":"add DLL functions for PIStages3 \"wait on\" functions support polldelay times fix GCSCommands.SGA() fix GCSCommands.qSPA() fix GCSCommands.qSEP() add optional argument \"noraise\" for StopAll(), HLT(), STP() add pitools.waitonfastalign() add pitools.waitonautozero() add GCS Error codes","title":"PIPython 1.3.5"},{"location":"history.html#pipython-134","text":"add pipython.interfaces.piserial \"wait on\" functions support predelay and postdelay times add GCSCommands.TSP() setup writes key for PIUpdateFinder always into 32 bit part of registry change formatting of numbers in GCS strings GCSDll supports \"K\" devices GCSMessages.bufstate will not write to log rename ReadGCSData() -> read_gcsdata() add controller C-663.12 add parameters for E-873.3QTU, C-663.10C885 add GCS Error codes bugfixing","title":"PIPython 1.3.4"},{"location":"history.html#pipython-133","text":"add GCSCommands.SGP() add GCSCommands.qSGP() add GCSCommands.WAV_SIN() add GCSCommands.WAV_POL() add GCSCommands.WAV_TAN() add GCSCommands.WAV_SWEEP() add GCSCommands.checkerror() add GCSCommands.DEL() add new controllers add controller parameters fix for handling unicode in Python 3 bugfixing of some GCS commands","title":"PIPython 1.3.3"},{"location":"history.html#pipython-132","text":"add GCSCommands.FSF() add GCSCommands.qFSF() add GCSCommands.qFSR() add pitools.getaxeslist() add pitools.ontarget() add pitools.waitonwalk() add pitools.waitonoma() add pitools.waitontrajectory() fix DLL function prefix","title":"PIPython 1.3.2"},{"location":"quickstart.html","text":"Quick Start Requirements Download these python packages with pip install: PyUSB PySocket PySerial Using pipython.interfaces.piusb , you can connect to a USB device without needing the GCS DLL. This only works on Linux and requires libusb, which comes with most Linux distributions. Establishing communication Communication with a PI device can be established via the GCSDevice class which wraps the GCS DLL functions and provides methods to connect to the device. Instantiate GCSDevice with the controller's product code up to the period as a string type argument (e.g., 'C-884' ). See Device Connection for further information. The following example connects to a C-884 series controller, queries its identification string using the qIDN() function and closes the connection. from pipython import GCSDevice pidevice = GCSDevice ( 'C-884' ) pidevice . InterfaceSetupDlg () print ( pidevice . qIDN ()) pidevice . CloseConnection () GCSDevice is a context manager which closes the connection if an exception is raised inside the with statement. Thus the example above should rather be written this way: from pipython import GCSDevice with GCSDevice ( 'C-884' ) as pidevice : pidevice . InterfaceSetupDlg () print ( pidevice . qIDN ()) pidevice . CloseConnection () See also quickstart.py , as well as the other examples in the samples subdirectory. Arguments Setter functions GCS 2.0 Setter functions can be called with the following argument structures: a comma-separated dictionary of axes/channels and values a comma-separated list of axes/channels and a list of the corresponding values a single axis/channel and a single value pidevice . MOV ({ 'X' : 1.23 , 'Y' : 2.34 }) pidevice . MOV ([ 'X' , 'Y' ], [ 1.23 , 2.34 ]) pidevice . MOV ( 'X' , 1.23 ) For numeric axis or channel identifiers, the quotes may be omitted. pidevice . MOV ({ 1 : 1.23 , 2 : 2.34 }) pidevice . MOV ([ 1 , 2 ], [ 1.23 , 2.34 ]) pidevice . MOV ( 1 , 1.23 ) GCS 3.0 Setter functions can be called with the following argument structures: a comma-separated dictionary of axes and values a comma-separated list of axes and a list of the corresponding values a single axis and a single value pidevice . MOV ({ 'AXIS_1' : 1.23 , 'AXIS_2' : 2.34 }) pidevice . MOV ([ 'AXIS_1' , 'AXIS_2' ], [ 1.23 , 2.34 ]) pidevice . MOV ( 'AXIS_1' , 1.23 ) Getter functions Getter functions can be called with the following argument structures: GCS 2.0 a comma-separated list of axes/channels a single axis/channel no arguments, which will return the answer for all available axes/channels For numeric axis or channel identifiers, the quotes may be omitted. pidevice . qPOS ([ 'X' , 'Y' ]) pidevice . qPOS ( 'X' ) pidevice . qPOS ( 1 ) pidevice . qPOS () GCS 3.0 a single axis no arguments, which will return the answer for all available axes or channels pidevice . qPOS ( 'AXIS_1' ) pidevice . qPOS () Return values GCS 2.0 Axes or channel related answers are returned as (ordered) dictionary. pidevice . qPOS () >> { 'X' : 1.23 , 'Y' : 2.34 } If a getter function is called with arguments, the data types of the arguments are preserved and can be used as keys. pos = pidevice . qPOS ([ 1 , 2 , 3 ]) print ( pos [ 1 ]) GCS 3.0 Axes or channel related answers are returned as (ordered) dictionary. pidevice . qPOS () >> { 'AXis_1' : 1.23 } If a getter function is called with arguments, the data types of the arguments are preserved and can be used as keys. pos = pidevice . qPOS ( 'AXIS_1' ) # only one axis is possible print ( pos [ 'AXIS_1' ]) GCS 2.0 / GCS 3.0 The following example moves all axes to their respective targets and waits until each motion has finished. It shows how to use only the values from the returned dictionary. from time import sleep # [...] pidevice . MOV ( axes , targets ) while not all ( list ( pidevice . qONT ( axes ) . values ())): sleep ( 0.1 ) Some useful information Helper functions With pipython.pitools you have some helper functions at hand that make coding more convenient. With waitontarget() for instance, the example above can be written like this: from pipython import pitools # [...] pidevice . MOV ( axes , targets ) pitools . waitontarget ( pidevice , axes ) See also the examples in the samples subdirectory. Debug logging To log debug messages on the console just enter these lines prior to calling GCSDevice . from pipython import PILogger , DEBUG , INFO , WARNING , ERROR , CRITICAL PILogger . setLevel ( DEBUG ) GCSError and error check By default an \"ERR?\" command is sent after each command to query if an error occurred on the device which then will be raised as GCSError exception. If communication speed is an issue you can disable error checking: pidevice . errcheck = False For the handling of GCSError exceptions you can use the defines provided by gcserror instead of pure numeric values. The difference between the two is: GCSError : exception class gcserror : corresponding module from pipython import GCSDevice , GCSError , gcserror with GCSDevice ( 'C-884' ) as pidevice : try : pidevice . MOV ( 'X' , 1.23 ) except GCSError as exc : if exc == gcserror . E_1024_PI_MOTION_ERROR : print ( 'There was a motion error, please check the mechanics.' ) else : raise The exception class GCSError translates the error code in a readable message. from pipython import GCSError , gcserror raise GCSError ( gcserror . E_1024_PI_MOTION_ERROR ) >>> GCSError : Motion error : position error too large , servo is switched off automatically ( - 1024 ) GCS 3.0 You can reset the error state of one or more axes like this: for axis in device . axes : if axis_has_error ( device ): while check_axis_status_bit ( device , axis , AXIS_STATUS_FAULT_REACTION_ACTIVE ): pass print ( 'reset axis error: ' , axis ) device . RES ( axis ) Big data Commands like qDRR() (GCS 2.0) or qREC_DAT() (GCS 3.0) which read a large amount of GCS data, return immediately with the header dictionary containing information about the data. Then they start a background task that carries on reading data from the device into an internal buffer. The bufstate property returns the progress of the read process as a floating point number (range 0 to 1) and becomes True when reading has finished. Hence, when using it in a loop, check for is not True . (Remember, this is not the same as != True .) GCS 2.0 header = pidevice . qDRR ( 1 , 1 , 8192 ) while pidevice . bufstate is not True : print ( 'read data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) data = pidevice . bufdata GCS 3.0 header = pidevice . qREC_DAT ( 'REC_1' , 'ASCII' , 1 , 1 , 8192 ) while pidevice . bufstate is not True : print ( 'read data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) data = pidevice . bufdata Textual interface In addition to using the functions implemented in GCSCommands you can send GCS commands as strings to the controller. Use read() for commands returning a response read_gcsdata() for commands returning GCS data send() for non-responding commands print ( pidevice . read ( 'POS?' )) print ( pidevice . read_gcsdata ( 'DRR? 1 100 1' )) pidevice . send ( 'MOV X 1.23' ) The commands return the raw string or GCS data from the controller. If errorcheck is activated the device is automatically queried for its error state. We recommend to use the provided functions instead of sending raw strings. In line with the C++ GCS DLL the functions ReadGCSCommand() and GcsCommandset() are also available. They don't query the device for errors. print ( pidevice . ReadGCSCommand ( 'POS?' )) pidevice . GcsCommandset ( 'MOV X 1.23' )","title":"Quick Start"},{"location":"quickstart.html#quick-start","text":"","title":"Quick Start"},{"location":"quickstart.html#requirements","text":"Download these python packages with pip install: PyUSB PySocket PySerial Using pipython.interfaces.piusb , you can connect to a USB device without needing the GCS DLL. This only works on Linux and requires libusb, which comes with most Linux distributions.","title":"Requirements"},{"location":"quickstart.html#establishing-communication","text":"Communication with a PI device can be established via the GCSDevice class which wraps the GCS DLL functions and provides methods to connect to the device. Instantiate GCSDevice with the controller's product code up to the period as a string type argument (e.g., 'C-884' ). See Device Connection for further information. The following example connects to a C-884 series controller, queries its identification string using the qIDN() function and closes the connection. from pipython import GCSDevice pidevice = GCSDevice ( 'C-884' ) pidevice . InterfaceSetupDlg () print ( pidevice . qIDN ()) pidevice . CloseConnection () GCSDevice is a context manager which closes the connection if an exception is raised inside the with statement. Thus the example above should rather be written this way: from pipython import GCSDevice with GCSDevice ( 'C-884' ) as pidevice : pidevice . InterfaceSetupDlg () print ( pidevice . qIDN ()) pidevice . CloseConnection () See also quickstart.py , as well as the other examples in the samples subdirectory.","title":"Establishing communication"},{"location":"quickstart.html#arguments","text":"","title":"Arguments"},{"location":"quickstart.html#setter-functions","text":"GCS 2.0 Setter functions can be called with the following argument structures: a comma-separated dictionary of axes/channels and values a comma-separated list of axes/channels and a list of the corresponding values a single axis/channel and a single value pidevice . MOV ({ 'X' : 1.23 , 'Y' : 2.34 }) pidevice . MOV ([ 'X' , 'Y' ], [ 1.23 , 2.34 ]) pidevice . MOV ( 'X' , 1.23 ) For numeric axis or channel identifiers, the quotes may be omitted. pidevice . MOV ({ 1 : 1.23 , 2 : 2.34 }) pidevice . MOV ([ 1 , 2 ], [ 1.23 , 2.34 ]) pidevice . MOV ( 1 , 1.23 ) GCS 3.0 Setter functions can be called with the following argument structures: a comma-separated dictionary of axes and values a comma-separated list of axes and a list of the corresponding values a single axis and a single value pidevice . MOV ({ 'AXIS_1' : 1.23 , 'AXIS_2' : 2.34 }) pidevice . MOV ([ 'AXIS_1' , 'AXIS_2' ], [ 1.23 , 2.34 ]) pidevice . MOV ( 'AXIS_1' , 1.23 )","title":"Setter functions"},{"location":"quickstart.html#getter-functions","text":"Getter functions can be called with the following argument structures: GCS 2.0 a comma-separated list of axes/channels a single axis/channel no arguments, which will return the answer for all available axes/channels For numeric axis or channel identifiers, the quotes may be omitted. pidevice . qPOS ([ 'X' , 'Y' ]) pidevice . qPOS ( 'X' ) pidevice . qPOS ( 1 ) pidevice . qPOS () GCS 3.0 a single axis no arguments, which will return the answer for all available axes or channels pidevice . qPOS ( 'AXIS_1' ) pidevice . qPOS ()","title":"Getter functions"},{"location":"quickstart.html#return-values","text":"GCS 2.0 Axes or channel related answers are returned as (ordered) dictionary. pidevice . qPOS () >> { 'X' : 1.23 , 'Y' : 2.34 } If a getter function is called with arguments, the data types of the arguments are preserved and can be used as keys. pos = pidevice . qPOS ([ 1 , 2 , 3 ]) print ( pos [ 1 ]) GCS 3.0 Axes or channel related answers are returned as (ordered) dictionary. pidevice . qPOS () >> { 'AXis_1' : 1.23 } If a getter function is called with arguments, the data types of the arguments are preserved and can be used as keys. pos = pidevice . qPOS ( 'AXIS_1' ) # only one axis is possible print ( pos [ 'AXIS_1' ]) GCS 2.0 / GCS 3.0 The following example moves all axes to their respective targets and waits until each motion has finished. It shows how to use only the values from the returned dictionary. from time import sleep # [...] pidevice . MOV ( axes , targets ) while not all ( list ( pidevice . qONT ( axes ) . values ())): sleep ( 0.1 )","title":"Return values"},{"location":"quickstart.html#some-useful-information","text":"","title":"Some useful information"},{"location":"quickstart.html#helper-functions","text":"With pipython.pitools you have some helper functions at hand that make coding more convenient. With waitontarget() for instance, the example above can be written like this: from pipython import pitools # [...] pidevice . MOV ( axes , targets ) pitools . waitontarget ( pidevice , axes ) See also the examples in the samples subdirectory.","title":"Helper functions"},{"location":"quickstart.html#debug-logging","text":"To log debug messages on the console just enter these lines prior to calling GCSDevice . from pipython import PILogger , DEBUG , INFO , WARNING , ERROR , CRITICAL PILogger . setLevel ( DEBUG )","title":"Debug logging"},{"location":"quickstart.html#gcserror-and-error-check","text":"By default an \"ERR?\" command is sent after each command to query if an error occurred on the device which then will be raised as GCSError exception. If communication speed is an issue you can disable error checking: pidevice . errcheck = False For the handling of GCSError exceptions you can use the defines provided by gcserror instead of pure numeric values. The difference between the two is: GCSError : exception class gcserror : corresponding module from pipython import GCSDevice , GCSError , gcserror with GCSDevice ( 'C-884' ) as pidevice : try : pidevice . MOV ( 'X' , 1.23 ) except GCSError as exc : if exc == gcserror . E_1024_PI_MOTION_ERROR : print ( 'There was a motion error, please check the mechanics.' ) else : raise The exception class GCSError translates the error code in a readable message. from pipython import GCSError , gcserror raise GCSError ( gcserror . E_1024_PI_MOTION_ERROR ) >>> GCSError : Motion error : position error too large , servo is switched off automatically ( - 1024 ) GCS 3.0 You can reset the error state of one or more axes like this: for axis in device . axes : if axis_has_error ( device ): while check_axis_status_bit ( device , axis , AXIS_STATUS_FAULT_REACTION_ACTIVE ): pass print ( 'reset axis error: ' , axis ) device . RES ( axis )","title":"GCSError and error check"},{"location":"quickstart.html#big-data","text":"Commands like qDRR() (GCS 2.0) or qREC_DAT() (GCS 3.0) which read a large amount of GCS data, return immediately with the header dictionary containing information about the data. Then they start a background task that carries on reading data from the device into an internal buffer. The bufstate property returns the progress of the read process as a floating point number (range 0 to 1) and becomes True when reading has finished. Hence, when using it in a loop, check for is not True . (Remember, this is not the same as != True .) GCS 2.0 header = pidevice . qDRR ( 1 , 1 , 8192 ) while pidevice . bufstate is not True : print ( 'read data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) data = pidevice . bufdata GCS 3.0 header = pidevice . qREC_DAT ( 'REC_1' , 'ASCII' , 1 , 1 , 8192 ) while pidevice . bufstate is not True : print ( 'read data {:.1f} %...' . format ( pidevice . bufstate * 100 )) sleep ( 0.1 ) data = pidevice . bufdata","title":"Big data"},{"location":"quickstart.html#textual-interface","text":"In addition to using the functions implemented in GCSCommands you can send GCS commands as strings to the controller. Use read() for commands returning a response read_gcsdata() for commands returning GCS data send() for non-responding commands print ( pidevice . read ( 'POS?' )) print ( pidevice . read_gcsdata ( 'DRR? 1 100 1' )) pidevice . send ( 'MOV X 1.23' ) The commands return the raw string or GCS data from the controller. If errorcheck is activated the device is automatically queried for its error state. We recommend to use the provided functions instead of sending raw strings. In line with the C++ GCS DLL the functions ReadGCSCommand() and GcsCommandset() are also available. They don't query the device for errors. print ( pidevice . ReadGCSCommand ( 'POS?' )) pidevice . GcsCommandset ( 'MOV X 1.23' )","title":"Textual interface"}]}