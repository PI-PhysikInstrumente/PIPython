{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"PIPython PIPython is a collection of Python modules to access a PI device and process GCS data. It can be used with Python 2.7+ and 3.4+ on Windows, Linux and OS X and without the GCS DLL also on any other platform. Quickstart Communicate to a PI device via GCSDevice which wraps the GCS DLL functions and provides methods to connect to the device. Call GCSDevice with the controller name as argument. from pipython import GCSDevice pidevice = GCSDevice('C-884') pidevice.InterfaceSetupDlg() print pidevice.qIDN() pidevice.CloseConnection() GCSDevice is a context manager which closes the connection if an exception raises inside the with statement. from pipython import GCSDevice with GCSDevice('C-884') as pidevice: pidevice.InterfaceSetupDlg() print(pidevice.qIDN()) See also the provided samples in the samples subdirectory. Start with quickstart.py . Requirements There are no dependencies to additional packages. With pipython.interfaces.piusb you can connect a USB device without using the GCS DLL. This works only with Linux and requires LibUSB which usually is provided by the OS. Arguments From now on pidevice refers to a connected GCSDevice instance. You can call a setter function with: a dictionary of axes/channels and values a list for axes/channels and a list of the values a single item for axis/channel and a single value pidevice.MOV({'X': 1.23, 'Y': 2.34}) pidevice.MOV(['X', 'Y'], [1.23, 2.34]) pidevice.MOV('X', 1.23) For channels and numeric axis names you can omit the quotes. pidevice.MOV({1: 1.23, 2: 2.34}) pidevice.MOV([1, 2], [1.23, 2.34]) pidevice.MOV(1, 1.23) Getter commands can be called with: a list of axes/channels a single item for axis/channel, without quotes if numeric without any arguments which will return the answer for all available axes/channels pidevice.qPOS(['X', 'Y']) pidevice.qPOS('X') pidevice.qPOS(1) pidevice.qPOS() Return values Axes or channel related answers are returned as (ordered) dictionary. pidevice.qPOS() >>>{'X': 1.23, 'Y': 2.34} If you provide arguments their types are preserved and you can use these as keys. pos = pidevice.qPOS([1, 2, 3]) print(pos[1]) If you do not provide arguments you always have to use strings as keys. pos = pidevice.qPOS() print(pos['1']) The following sample will move all axes to targets and waits until the motion has finished. It shows how to use only the values from the returned dictionary. from time import sleep ... pidevice.MOV(axes, targets) while not all(list(pidevice.qONT(axes).values())): sleep(0.1) Some hints... Helpers In pipython.pitools you will find some helper funtions for your convenience. See the provided samples for how to use them. The sample above can then be written as: from pipython import pitools ... pidevice.MOV(axes, targets) pitools.waitontarget(pidevice, axes) Enable debug logging To log debug messages on the console just enter these lines prior to calling GCSDevice . from logging import basicConfig, DEBUG basicConfig(level=DEBUG) GCSError and error check By default an \"ERR?\" command is sent after each command to query if an error occurred on the device which then will be raised as GCSError exception. If communication speed is an issue you can disable error checking. pidevice.errcheck = False To handle a catched GCSError exception you can use the defines provided by gcserror instead of pure numeric values. Remember the difference between GCSError which is the exception class and gcserror which is the according module. from pipython import GCSDevice, GCSError, gcserror with GCSDevice('C-884') as pidevice: try: pidevice.MOV('X', 1.23) except GCSError as exc: if exc == gcserror.E_1024_PI_MOTION_ERROR: print('There was a motion error, please check the mechanics.') else: raise The exception class GCSError will translate the error code into a readable message. from pipython import GCSError, gcserror raise GCSError(gcserror.E_1024_PI_MOTION_ERROR) >>>GCSError: Motion error: position error too large, servo is switched off automatically (-1024) Big data Commands like qDRR() which read a large amount of GCS data return immediately with the header dictionary containing information about the data. Then they will start a background task that carries on reading data from the device into an internal buffer. The bufstate property returns the progress of the reading as floating point number in the range 0 to 1 and turns to True when reading has finished. Hence, when using it in a loop check for is not True . (Remember, this is not the same as != True .) header = pidevice.qDRR(1, 1, 8192) while pidevice.bufstate is not True: print('read data {:.1f}%...'.format(pidevice.bufstate * 100)) sleep(0.1) data = pidevice.bufdata Textual interface Besides the functions implemented in GCSCommands you can send GCS commands as strings to the controller. Use read() for commands returning an answer, read_gcsdata() for commands returning GCS data and send() for non-answering commands. print(pidevice.read('POS?')) print(pidevice.read_gcsdata('DRR? 1 100 1')) pidevice.send('MOV X 1.23') They return the raw string or GCS data from the controller. If errorcheck is enabled the error state is queried from the device automatically. We recommend to use the provided functions instead of sending raw strings. In line with the C++ GCS DLL the functions ReadGCSCommand() and GcsCommandset() are also available. They will never query an error from the device. print(pidevice.ReadGCSCommand('POS?')) pidevice.GcsCommandset('MOV X 1.23')","title":"Home"},{"location":"index.html#pipython","text":"PIPython is a collection of Python modules to access a PI device and process GCS data. It can be used with Python 2.7+ and 3.4+ on Windows, Linux and OS X and without the GCS DLL also on any other platform.","title":"PIPython"},{"location":"index.html#quickstart","text":"Communicate to a PI device via GCSDevice which wraps the GCS DLL functions and provides methods to connect to the device. Call GCSDevice with the controller name as argument. from pipython import GCSDevice pidevice = GCSDevice('C-884') pidevice.InterfaceSetupDlg() print pidevice.qIDN() pidevice.CloseConnection() GCSDevice is a context manager which closes the connection if an exception raises inside the with statement. from pipython import GCSDevice with GCSDevice('C-884') as pidevice: pidevice.InterfaceSetupDlg() print(pidevice.qIDN()) See also the provided samples in the samples subdirectory. Start with quickstart.py .","title":"Quickstart"},{"location":"index.html#requirements","text":"There are no dependencies to additional packages. With pipython.interfaces.piusb you can connect a USB device without using the GCS DLL. This works only with Linux and requires LibUSB which usually is provided by the OS.","title":"Requirements"},{"location":"index.html#arguments","text":"From now on pidevice refers to a connected GCSDevice instance. You can call a setter function with: a dictionary of axes/channels and values a list for axes/channels and a list of the values a single item for axis/channel and a single value pidevice.MOV({'X': 1.23, 'Y': 2.34}) pidevice.MOV(['X', 'Y'], [1.23, 2.34]) pidevice.MOV('X', 1.23) For channels and numeric axis names you can omit the quotes. pidevice.MOV({1: 1.23, 2: 2.34}) pidevice.MOV([1, 2], [1.23, 2.34]) pidevice.MOV(1, 1.23) Getter commands can be called with: a list of axes/channels a single item for axis/channel, without quotes if numeric without any arguments which will return the answer for all available axes/channels pidevice.qPOS(['X', 'Y']) pidevice.qPOS('X') pidevice.qPOS(1) pidevice.qPOS()","title":"Arguments"},{"location":"index.html#return-values","text":"Axes or channel related answers are returned as (ordered) dictionary. pidevice.qPOS() >>>{'X': 1.23, 'Y': 2.34} If you provide arguments their types are preserved and you can use these as keys. pos = pidevice.qPOS([1, 2, 3]) print(pos[1]) If you do not provide arguments you always have to use strings as keys. pos = pidevice.qPOS() print(pos['1']) The following sample will move all axes to targets and waits until the motion has finished. It shows how to use only the values from the returned dictionary. from time import sleep ... pidevice.MOV(axes, targets) while not all(list(pidevice.qONT(axes).values())): sleep(0.1)","title":"Return values"},{"location":"index.html#some-hints","text":"","title":"Some hints..."},{"location":"index.html#helpers","text":"In pipython.pitools you will find some helper funtions for your convenience. See the provided samples for how to use them. The sample above can then be written as: from pipython import pitools ... pidevice.MOV(axes, targets) pitools.waitontarget(pidevice, axes)","title":"Helpers"},{"location":"index.html#enable-debug-logging","text":"To log debug messages on the console just enter these lines prior to calling GCSDevice . from logging import basicConfig, DEBUG basicConfig(level=DEBUG)","title":"Enable debug logging"},{"location":"index.html#gcserror-and-error-check","text":"By default an \"ERR?\" command is sent after each command to query if an error occurred on the device which then will be raised as GCSError exception. If communication speed is an issue you can disable error checking. pidevice.errcheck = False To handle a catched GCSError exception you can use the defines provided by gcserror instead of pure numeric values. Remember the difference between GCSError which is the exception class and gcserror which is the according module. from pipython import GCSDevice, GCSError, gcserror with GCSDevice('C-884') as pidevice: try: pidevice.MOV('X', 1.23) except GCSError as exc: if exc == gcserror.E_1024_PI_MOTION_ERROR: print('There was a motion error, please check the mechanics.') else: raise The exception class GCSError will translate the error code into a readable message. from pipython import GCSError, gcserror raise GCSError(gcserror.E_1024_PI_MOTION_ERROR) >>>GCSError: Motion error: position error too large, servo is switched off automatically (-1024)","title":"GCSError and error check"},{"location":"index.html#big-data","text":"Commands like qDRR() which read a large amount of GCS data return immediately with the header dictionary containing information about the data. Then they will start a background task that carries on reading data from the device into an internal buffer. The bufstate property returns the progress of the reading as floating point number in the range 0 to 1 and turns to True when reading has finished. Hence, when using it in a loop check for is not True . (Remember, this is not the same as != True .) header = pidevice.qDRR(1, 1, 8192) while pidevice.bufstate is not True: print('read data {:.1f}%...'.format(pidevice.bufstate * 100)) sleep(0.1) data = pidevice.bufdata","title":"Big data"},{"location":"index.html#textual-interface","text":"Besides the functions implemented in GCSCommands you can send GCS commands as strings to the controller. Use read() for commands returning an answer, read_gcsdata() for commands returning GCS data and send() for non-answering commands. print(pidevice.read('POS?')) print(pidevice.read_gcsdata('DRR? 1 100 1')) pidevice.send('MOV X 1.23') They return the raw string or GCS data from the controller. If errorcheck is enabled the error state is queried from the device automatically. We recommend to use the provided functions instead of sending raw strings. In line with the C++ GCS DLL the functions ReadGCSCommand() and GcsCommandset() are also available. They will never query an error from the device. print(pidevice.ReadGCSCommand('POS?')) pidevice.GcsCommandset('MOV X 1.23')","title":"Textual interface"},{"location":"connect.html","text":"Device connection Here you will find sample code for how to connect one ore more PI devices. For further reading see the python scripts in the samples subdirectory. Connect a single device via the GCS DLL By a dialog On Windows systems the GCS DLL provides a graphical user interface to select the interface and parameters. from pipython import GCSDevice with GCSDevice() as pidevice: pidevice.InterfaceSetupDlg() print('connected: {}'.format(pidevice.qIDN().strip())) If you pass an optional key as arbitrary string to the InterfaceSetupDlg method, the DLL remembers the settings in the Windows registry and will recall them the next time you connect with the same key. from pipython import GCSDevice with GCSDevice() as pidevice: pidevice.InterfaceSetupDlg('MyTest') print('connected: {}'.format(pidevice.qIDN().strip())) By a dedicated interface You can connect via these interfaces with the according methods. RS-232: ConnectRS232(comport, baudrate) USB: ConnectUSB(serialnum) TCP/IP: ConnectTCPIP(ipaddress, ipport=50000) TCP/IP: ConnectTCPIPByDescription(description) NI GPIB: ConnectNIgpib(board, device) PCI board: ConnectPciBoard(board) from pipython import GCSDevice with GCSDevice() as pidevice: pidevice.ConnectTCPIP('192.168.178.42') print('connected: {}'.format(pidevice.qIDN().strip())) The parameter serialnum can be the serial number of the device as string or the device identification returned by EnumerateUSB . For TCP/IP ConnectTCPIP connects by given IP address where ConnectTCPIPByDescription uses the string from EnumerateTCPIPDevices . By the device identification There are functions to scan for available devices. USB: EnumerateUSB(mask='') TCPIP: EnumerateTCPIPDevices(mask='') Use the mask to limit the number of found devices. It is a string that must be part of the identification string - see qIDN - returned by the devices. from pipython import GCSDevice with GCSDevice() as pidevice: devices = pidevice.EnumerateTCPIPDevices(mask='C-884.4DB') for i, device in enumerate(devices): print('{} - {}'.format(i, device)) item = int(input('Select device to connect:')) pidevice.ConnectTCPIPByDescription(devices[item]) print('connected: {}'.format(pidevice.qIDN().strip())) Connect daisy chain devices You have to open the interface once and than you connect all devices to this interface. Each device must have a unique ID on the daisy chain (see controller manual). There must be one device with ID1 which needs not to be the master device (i.e. connected to the PC). See an example for 3 devices on an RS-232 daisy chain. C-863 controller with device ID 3, this is the master device E-861 controller with device ID 7 C-867 controller with device ID 1 There is no need to close the connections. This is done automatically because GCSDevice is used as context manager. from pipython import GCSDevice with GCSDevice() as c863: c863.OpenRS232DaisyChain(comport=1, baudrate=115200) # c863.OpenUSBDaisyChain(description='1234567890') # c863.OpenTCPIPDaisyChain(ipaddress='192.168.178.42') daisychainid = c863.dcid c863.ConnectDaisyChainDevice(3, daisychainid) with GCSDevice() as e861: e861.ConnectDaisyChainDevice(7, daisychainid) with GCSDevice() as c867: c867.ConnectDaisyChainDevice(1, daisychainid) print('\\n{}:\\n{}'.format(c863.GetInterfaceDescription(), c863.qIDN())) print('\\n{}:\\n{}'.format(e861.GetInterfaceDescription(), e861.qIDN())) print('\\n{}:\\n{}'.format(c867.GetInterfaceDescription(), c867.qIDN())) Low level interface Usually you connect with GCSDevice via the GCS DLL. But on platforms where the GCS DLL is not available you are still able to connect. By PISocket: from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.pisocket import PISocket with PISocket(host='192.168.178.42', port=50000) as gateway: messages = GCSMessages(gateway) pidevice = GCSCommands(messages) print(pidevice.qIDN()) By PISerial: from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piserial import PISerial with PISerial(port=1, baudrate=115200) as gateway: messages = GCSMessages(gateway) pidevice = GCSCommands(messages) print(pidevice.qIDN()) By PIUSB: This interface requires LibUSB which usually is only available on Linux like operation systems. Hint: Run pip install pyusb . from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piusb import PIUSB with PIUSB() as gateway: gateway.connect(serialnumber='1234567890', pid=0x1234) messages = GCSMessages(gateway) pidevice = GCSCommands(messages) print(pidevice.qIDN()) Unknown devices When you call GCSDevice with the controller name the according GCS DLL is chosen automatically. For unknown devices you can specify a dedicated GCS DLL instead. from pipython import GCSDevice with GCSDevice(gcsdll='PI_GCS2_DLL.dll') as pidevice: pidevice.InterfaceSetupDlg()","title":"Device Connection"},{"location":"connect.html#device-connection","text":"Here you will find sample code for how to connect one ore more PI devices. For further reading see the python scripts in the samples subdirectory.","title":"Device connection"},{"location":"connect.html#connect-a-single-device-via-the-gcs-dll","text":"","title":"Connect a single device via the GCS DLL"},{"location":"connect.html#by-a-dialog","text":"On Windows systems the GCS DLL provides a graphical user interface to select the interface and parameters. from pipython import GCSDevice with GCSDevice() as pidevice: pidevice.InterfaceSetupDlg() print('connected: {}'.format(pidevice.qIDN().strip())) If you pass an optional key as arbitrary string to the InterfaceSetupDlg method, the DLL remembers the settings in the Windows registry and will recall them the next time you connect with the same key. from pipython import GCSDevice with GCSDevice() as pidevice: pidevice.InterfaceSetupDlg('MyTest') print('connected: {}'.format(pidevice.qIDN().strip()))","title":"By a dialog"},{"location":"connect.html#by-a-dedicated-interface","text":"You can connect via these interfaces with the according methods. RS-232: ConnectRS232(comport, baudrate) USB: ConnectUSB(serialnum) TCP/IP: ConnectTCPIP(ipaddress, ipport=50000) TCP/IP: ConnectTCPIPByDescription(description) NI GPIB: ConnectNIgpib(board, device) PCI board: ConnectPciBoard(board) from pipython import GCSDevice with GCSDevice() as pidevice: pidevice.ConnectTCPIP('192.168.178.42') print('connected: {}'.format(pidevice.qIDN().strip())) The parameter serialnum can be the serial number of the device as string or the device identification returned by EnumerateUSB . For TCP/IP ConnectTCPIP connects by given IP address where ConnectTCPIPByDescription uses the string from EnumerateTCPIPDevices .","title":"By a dedicated interface"},{"location":"connect.html#by-the-device-identification","text":"There are functions to scan for available devices. USB: EnumerateUSB(mask='') TCPIP: EnumerateTCPIPDevices(mask='') Use the mask to limit the number of found devices. It is a string that must be part of the identification string - see qIDN - returned by the devices. from pipython import GCSDevice with GCSDevice() as pidevice: devices = pidevice.EnumerateTCPIPDevices(mask='C-884.4DB') for i, device in enumerate(devices): print('{} - {}'.format(i, device)) item = int(input('Select device to connect:')) pidevice.ConnectTCPIPByDescription(devices[item]) print('connected: {}'.format(pidevice.qIDN().strip()))","title":"By the device identification"},{"location":"connect.html#connect-daisy-chain-devices","text":"You have to open the interface once and than you connect all devices to this interface. Each device must have a unique ID on the daisy chain (see controller manual). There must be one device with ID1 which needs not to be the master device (i.e. connected to the PC). See an example for 3 devices on an RS-232 daisy chain. C-863 controller with device ID 3, this is the master device E-861 controller with device ID 7 C-867 controller with device ID 1 There is no need to close the connections. This is done automatically because GCSDevice is used as context manager. from pipython import GCSDevice with GCSDevice() as c863: c863.OpenRS232DaisyChain(comport=1, baudrate=115200) # c863.OpenUSBDaisyChain(description='1234567890') # c863.OpenTCPIPDaisyChain(ipaddress='192.168.178.42') daisychainid = c863.dcid c863.ConnectDaisyChainDevice(3, daisychainid) with GCSDevice() as e861: e861.ConnectDaisyChainDevice(7, daisychainid) with GCSDevice() as c867: c867.ConnectDaisyChainDevice(1, daisychainid) print('\\n{}:\\n{}'.format(c863.GetInterfaceDescription(), c863.qIDN())) print('\\n{}:\\n{}'.format(e861.GetInterfaceDescription(), e861.qIDN())) print('\\n{}:\\n{}'.format(c867.GetInterfaceDescription(), c867.qIDN()))","title":"Connect daisy chain devices"},{"location":"connect.html#low-level-interface","text":"Usually you connect with GCSDevice via the GCS DLL. But on platforms where the GCS DLL is not available you are still able to connect.","title":"Low level interface"},{"location":"connect.html#by-pisocket","text":"from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.pisocket import PISocket with PISocket(host='192.168.178.42', port=50000) as gateway: messages = GCSMessages(gateway) pidevice = GCSCommands(messages) print(pidevice.qIDN())","title":"By PISocket:"},{"location":"connect.html#by-piserial","text":"from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piserial import PISerial with PISerial(port=1, baudrate=115200) as gateway: messages = GCSMessages(gateway) pidevice = GCSCommands(messages) print(pidevice.qIDN())","title":"By PISerial:"},{"location":"connect.html#by-piusb","text":"This interface requires LibUSB which usually is only available on Linux like operation systems. Hint: Run pip install pyusb . from pipython.pidevice.gcscommands import GCSCommands from pipython.pidevice.gcsmessages import GCSMessages from pipython.pidevice.interfaces.piusb import PIUSB with PIUSB() as gateway: gateway.connect(serialnumber='1234567890', pid=0x1234) messages = GCSMessages(gateway) pidevice = GCSCommands(messages) print(pidevice.qIDN())","title":"By PIUSB:"},{"location":"connect.html#unknown-devices","text":"When you call GCSDevice with the controller name the according GCS DLL is chosen automatically. For unknown devices you can specify a dedicated GCS DLL instead. from pipython import GCSDevice with GCSDevice(gcsdll='PI_GCS2_DLL.dll') as pidevice: pidevice.InterfaceSetupDlg()","title":"Unknown devices"},{"location":"datarecorder.html","text":"Data recorder A PI device has one or more record tables that can be filled with float values (i.e. numbers). The typical workflow is as following. Set the record rate. Configure the data to be recorded. Configure the trigger event that starts the recorder. Perform the action that should be recorded. Wait until the action is finished. Wait until the data has been recorded. Start reading out the data from the controller. Wait until all data has been read out from the device. Process the data. Please find an according sample in samples/datarecorder.py . Prepare the data recorder Set the record rate With the GCS command RTR you can set the record rate in multiples of the device specific servo loop time. Hence the higher the RTR rate is the slower the data is recorded. For your convenience the Datarecorder() class takes a record rate in Hertz and seconds, too. from pipython import GCSDevice from pipython import datarectools, pitools pidevice = GCSDevice() pidevice.InterfaceSetupDlg() ... drec = datarectools.Datarecorder(pidevice) # drec.samplerate = 1 # servo cycles # drec.sampletime = 1E-5 # seconds drec.samplefrequ = 1000 # Hertz print('data recorder rate: {:d} servo cycles'.format(drec.samplerate)) print('data recorder rate: {:.g} seconds'.format(drec.sampletime)) print('data recorder rate: {:.2f} Hertz'.format(drec.samplefrequ)) Set the record time By default the entire data recorder memory is used to record the data. You can reduce the number of points with the numvalues property. Or you set the time to record in seconds with rectime which adjusts numvalues accordingly. The rectimemax property will use the entire data recorder memory and will adjust the samplerate accordingly. Further on pidevice is referred as instance of pipython.GCSDevice and drec is referred as instance of pipython.datarectools.Datarecorder. Configure data recorder With the GCS command DRC you can configure which measurement (the record option ) of which record source (e.g. an axis or channel) is recorded in a specified record table . There is an enumeration pipython.datarectools.RecordOptions available. The function Datarecorder.record() takes one or more axes , one or more record options and one or more trigger options . If you call it with a single axis and several record options it will take the given axis for all recordings. And vice versa it will take a single record option for several given axes . When you omit the axes argument all connected axes are taken. If you omit the record option then RecordOptions.ACTUAL_POSITION_2 is taken. It will return a list of record table IDs where the desired data will be stored. See the example code below. Configure the trigger event With the GCS command DRT you can configure when the recording will start, e.g. immediately or with the next command that changes a position , i.e. that makes a motion. There is an enumeration pipython.datarectools.TriggerSources available. If you call the function Datarecorder.record() with a single value as trigger option it will use the DRT command with the record table \"0\". If it is called with a list as argument it will use DRT with the according record table IDs. See the controller user manual which is the appropriate way for your device. If you omit the trigger options argument then TriggerSources.NEXT_COMMAND_WITH_RESET_2 is taken. If TriggerSources.NEXT_COMMAND_WITH_RESET_2 is used then the error check will be disabled automatically. The following sample will configure two recordings of one axis triggered by a position changing command and arm the data recorder. drec.options = (datarectools.RecordOptions.ACTUAL_POSITION_2, datarectools.RecordOptions.COMMANDED_POSITION_1) drec.sources = pidevice.axes[0] drec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1 drec.arm() The following sample will configure two recordings of two axes. drec.options = datarectools.RecordOptions.ACTUAL_POSITION_2 drec.sources = ['X', 'Y'] drec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1 drec.arm() The following sample will configure four recordings of two analog inputs and two measurements regarding axis X. drec.sources = [1, 2, 'X', 'X'] drec.options = [datarectools.RecordOptions.ANALOG_INPUT_81, datarectools.RecordOptions.ANALOG_INPUT_81, datarectools.RecordOptions.MOTOR_OUTPUT_73, datarectools.RecordOptions.COMMANDED_POSITION_1] drec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1 drec.arm() Get options from string If you read the desired options for example from an INI file there are helper functions getrecopt() and gettrigsources() to translate a descriptive string into the according option value. The following example will set trigsources to POSITION_CHANGING_COMMAND_1 . readout = 'pos_chg_cmd' # e.g. from an INI file drec.trigsources = datarectools.gettrigsources(readout) The first exact or abbreviated match of all parts of an option (i.e. in the example \"POSITION\", \"CHANGING\" and \"COMMAND\") is returned. The descriptive string is case insensitive. Use \"_\" as separator. The trailing number in the option name is not required for a match. Abbreviations must start with the first letter of the according part of an option. Get the data Wait for the motion to finish After you started the triggering event (for example a motion) you can wait until the motion has finished with the \"wait\" helper functions in pipython.pitools . pidevice.MVR(axis, 1.0) pitools.waitontarget(pidevice, axis) Get the data recorder data Finally you will read out the recorded data from the device with the GCS command qDRR . This command returns immediately with the GCS header containing information about the data recorder data. Then it starts a background task that keeps on storing the data still coming from the controller in an internal buffer. Check the current state of this buffer with the bufstate property. It will turn True when the task has finshed. Prior to that it is a float value in the range 0..1 indicating the progress of the data transfer. Hence end a loop with while bufstate is not True and not with while not bufstate . header = pidevice.qDRR(rectables, offset, numvalues) while pidevice.bufstate is not True: print('read data {:.1f}%...'.format(pidevice.bufstate * 100)) sleep(0.1) Remember that the task running in the background will lock the communication to the device. Hence your application indeed is able to continue after the qDRR command but when you try to communicate to the device during data readout this will result in a deadlock! To prevent this always check the GCSDevice.locked property. For your convenience you can use Datarecorder.getdata() instead. It will wait until the desired data has been recorded and will then return the header and the data as two-dimensional list where the first index indicates the record table and the second index indicates the value in this record table. header, data = drec.getdata() Process data The sample below shows how to use the header and the data from a recording of two tables to create a plot. (This requires matplotlib.) timescale = [header['SAMPLE_TIME'] * i for i in range(len(data[0]))] pyplot.plot(timescale, data[0], color='red') pyplot.plot(timescale, data[1], color='blue') pyplot.xlabel('time (s)') pyplot.ylabel(', '.join((header['NAME0'], header['NAME1']))) pyplot.title('Datarecorder data over time') pyplot.grid(True) pyplot.show() If you are used to NumPy you can easily convert the datarecorder data into a NumPy array. import numpy as np ... header, data = drec.getdata() npdata = np.array(data) Appendix Wait for recording To wait for the data recording to finish you can use wait() and read() instead of getdata() drec.arm() drec.wait() # recording is now finished header, data = drec.read()","title":"Datarecorder"},{"location":"datarecorder.html#data-recorder","text":"A PI device has one or more record tables that can be filled with float values (i.e. numbers). The typical workflow is as following. Set the record rate. Configure the data to be recorded. Configure the trigger event that starts the recorder. Perform the action that should be recorded. Wait until the action is finished. Wait until the data has been recorded. Start reading out the data from the controller. Wait until all data has been read out from the device. Process the data. Please find an according sample in samples/datarecorder.py .","title":"Data recorder"},{"location":"datarecorder.html#prepare-the-data-recorder","text":"","title":"Prepare the data recorder"},{"location":"datarecorder.html#set-the-record-rate","text":"With the GCS command RTR you can set the record rate in multiples of the device specific servo loop time. Hence the higher the RTR rate is the slower the data is recorded. For your convenience the Datarecorder() class takes a record rate in Hertz and seconds, too. from pipython import GCSDevice from pipython import datarectools, pitools pidevice = GCSDevice() pidevice.InterfaceSetupDlg() ... drec = datarectools.Datarecorder(pidevice) # drec.samplerate = 1 # servo cycles # drec.sampletime = 1E-5 # seconds drec.samplefrequ = 1000 # Hertz print('data recorder rate: {:d} servo cycles'.format(drec.samplerate)) print('data recorder rate: {:.g} seconds'.format(drec.sampletime)) print('data recorder rate: {:.2f} Hertz'.format(drec.samplefrequ))","title":"Set the record rate"},{"location":"datarecorder.html#set-the-record-time","text":"By default the entire data recorder memory is used to record the data. You can reduce the number of points with the numvalues property. Or you set the time to record in seconds with rectime which adjusts numvalues accordingly. The rectimemax property will use the entire data recorder memory and will adjust the samplerate accordingly. Further on pidevice is referred as instance of pipython.GCSDevice and drec is referred as instance of pipython.datarectools.Datarecorder.","title":"Set the record time"},{"location":"datarecorder.html#configure-data-recorder","text":"With the GCS command DRC you can configure which measurement (the record option ) of which record source (e.g. an axis or channel) is recorded in a specified record table . There is an enumeration pipython.datarectools.RecordOptions available. The function Datarecorder.record() takes one or more axes , one or more record options and one or more trigger options . If you call it with a single axis and several record options it will take the given axis for all recordings. And vice versa it will take a single record option for several given axes . When you omit the axes argument all connected axes are taken. If you omit the record option then RecordOptions.ACTUAL_POSITION_2 is taken. It will return a list of record table IDs where the desired data will be stored. See the example code below.","title":"Configure data recorder"},{"location":"datarecorder.html#configure-the-trigger-event","text":"With the GCS command DRT you can configure when the recording will start, e.g. immediately or with the next command that changes a position , i.e. that makes a motion. There is an enumeration pipython.datarectools.TriggerSources available. If you call the function Datarecorder.record() with a single value as trigger option it will use the DRT command with the record table \"0\". If it is called with a list as argument it will use DRT with the according record table IDs. See the controller user manual which is the appropriate way for your device. If you omit the trigger options argument then TriggerSources.NEXT_COMMAND_WITH_RESET_2 is taken. If TriggerSources.NEXT_COMMAND_WITH_RESET_2 is used then the error check will be disabled automatically. The following sample will configure two recordings of one axis triggered by a position changing command and arm the data recorder. drec.options = (datarectools.RecordOptions.ACTUAL_POSITION_2, datarectools.RecordOptions.COMMANDED_POSITION_1) drec.sources = pidevice.axes[0] drec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1 drec.arm() The following sample will configure two recordings of two axes. drec.options = datarectools.RecordOptions.ACTUAL_POSITION_2 drec.sources = ['X', 'Y'] drec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1 drec.arm() The following sample will configure four recordings of two analog inputs and two measurements regarding axis X. drec.sources = [1, 2, 'X', 'X'] drec.options = [datarectools.RecordOptions.ANALOG_INPUT_81, datarectools.RecordOptions.ANALOG_INPUT_81, datarectools.RecordOptions.MOTOR_OUTPUT_73, datarectools.RecordOptions.COMMANDED_POSITION_1] drec.trigsources = datarectools.TriggerSources.POSITION_CHANGING_COMMAND_1 drec.arm()","title":"Configure the trigger event"},{"location":"datarecorder.html#get-options-from-string","text":"If you read the desired options for example from an INI file there are helper functions getrecopt() and gettrigsources() to translate a descriptive string into the according option value. The following example will set trigsources to POSITION_CHANGING_COMMAND_1 . readout = 'pos_chg_cmd' # e.g. from an INI file drec.trigsources = datarectools.gettrigsources(readout) The first exact or abbreviated match of all parts of an option (i.e. in the example \"POSITION\", \"CHANGING\" and \"COMMAND\") is returned. The descriptive string is case insensitive. Use \"_\" as separator. The trailing number in the option name is not required for a match. Abbreviations must start with the first letter of the according part of an option.","title":"Get options from string"},{"location":"datarecorder.html#get-the-data","text":"","title":"Get the data"},{"location":"datarecorder.html#wait-for-the-motion-to-finish","text":"After you started the triggering event (for example a motion) you can wait until the motion has finished with the \"wait\" helper functions in pipython.pitools . pidevice.MVR(axis, 1.0) pitools.waitontarget(pidevice, axis)","title":"Wait for the motion to finish"},{"location":"datarecorder.html#get-the-data-recorder-data","text":"Finally you will read out the recorded data from the device with the GCS command qDRR . This command returns immediately with the GCS header containing information about the data recorder data. Then it starts a background task that keeps on storing the data still coming from the controller in an internal buffer. Check the current state of this buffer with the bufstate property. It will turn True when the task has finshed. Prior to that it is a float value in the range 0..1 indicating the progress of the data transfer. Hence end a loop with while bufstate is not True and not with while not bufstate . header = pidevice.qDRR(rectables, offset, numvalues) while pidevice.bufstate is not True: print('read data {:.1f}%...'.format(pidevice.bufstate * 100)) sleep(0.1) Remember that the task running in the background will lock the communication to the device. Hence your application indeed is able to continue after the qDRR command but when you try to communicate to the device during data readout this will result in a deadlock! To prevent this always check the GCSDevice.locked property. For your convenience you can use Datarecorder.getdata() instead. It will wait until the desired data has been recorded and will then return the header and the data as two-dimensional list where the first index indicates the record table and the second index indicates the value in this record table. header, data = drec.getdata()","title":"Get the data recorder data"},{"location":"datarecorder.html#process-data","text":"The sample below shows how to use the header and the data from a recording of two tables to create a plot. (This requires matplotlib.) timescale = [header['SAMPLE_TIME'] * i for i in range(len(data[0]))] pyplot.plot(timescale, data[0], color='red') pyplot.plot(timescale, data[1], color='blue') pyplot.xlabel('time (s)') pyplot.ylabel(', '.join((header['NAME0'], header['NAME1']))) pyplot.title('Datarecorder data over time') pyplot.grid(True) pyplot.show() If you are used to NumPy you can easily convert the datarecorder data into a NumPy array. import numpy as np ... header, data = drec.getdata() npdata = np.array(data)","title":"Process data"},{"location":"datarecorder.html#appendix","text":"","title":"Appendix"},{"location":"datarecorder.html#wait-for-recording","text":"To wait for the data recording to finish you can use wait() and read() instead of getdata() drec.arm() drec.wait() # recording is now finished header, data = drec.read()","title":"Wait for recording"},{"location":"eula.html","text":"License Agreement General Software License Agreement of Physik Instrumente (PI) GmbH & Co. KG Issued: April 16, 2018 Preamble Physik Instrumente (PI) GmbH & Co. KG (hereinafter referred to as \"PI\") is a manufacturer and provider of micro- and nanopositioning technology and motion control systems, devices and apparatuses including their respective firmware (hereinafter jointly referred to as \"the PI Hardware\"), which can either be used independently or as an integral part of other third-party hardware systems. For the purpose of operating the PI Hardware, PI provides its customers, which either purchase the PI Hardware directly from PI for their own use or which integrate the PI Hardware into third-party hardware systems for distribution to their clients (hereinafter jointly referred to as \"the Customer\") with software products or tools (hereinafter jointly referred to as \"the Software\"). The following general terms and conditions (hereinafter referred to as \"Terms and Conditions\") shall apply to any Software provided by PI to the Customer, unless expressly agreed or stated otherwise herein, and may be supplemented by specific terms and conditions for individual software components. I. Scope (1) These Terms and Conditions shall apply to the supply of Software for its use together with PI Hardware and the granting of rights of use to the Customer, as described below. (2) The Software is supplied by PI to the Customer either in machine-readable form or with regard to certain software components in machine-readable form together with its source code and is subject to the following Terms and Conditions, unless PI and the Customer have agreed otherwise in writing. (3) These Terms and Conditions shall not apply to the PI Hardware. (4) PI does not owe any installation and configuration services under these Terms and Conditions. (5) The Software is not designed for use in medical devices (Medizinprodukt) according to section 3 of the German Act on Medical Devices (MPG). (6) References to the application of statutory provisions only serve clarification purposes. Therefore, the statutory provisions apply even without such clarification, unless modified directly by these Terms and Conditions. II. Rights of Use (1) Unless stated otherwise herein, PI grants to the Customer a non-exclusive territorially unrestricted right to use the Software for an unlimited period of time on the basis of the following provisions. (2) The following restrictions apply, if not explicitly agreed otherwise: (i) The Customer shall be entitled to use the Software insofar as this is required for the contractually agreed or contractually intended use of the Software and in accordance with these Terms and Conditions, including the right to install the Software onto a hard disk drive and/or to load it into the random access memory (RAM). If not specified otherwise, the Customer is entitled to use the Software within its company on several devices or on several workstations simultaneously and to duplicate the Software for that purpose. In the event that the use of the Software depends on a prior activation and is therefore limited to a certain license key (to be individually purchased by the Customer from PI), the use of the affected Software shall however be restricted to the respective device for which the Software has been activated by the Customer. The Software shall in any case be used by the Customer exclusively for and in relation with the operation of PI Hardware. The Customer shall insofar however be entitled to use the Software together with third-party software or to combine the Software with third-party software products, as far as necessary to operate its or any third-party systems that do include the PI Hardware. (ii) The Customer shall furthermore be entitled to generate application-specific, loadable and executable software products with the Software and to transfer such software products to third parties only for use for and in relation with the operation of PI Hardware. Such third party shall not be granted any rights of use beyond the rights of use granted to Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party shall be bound by the contractual obligations under these Terms and Conditions with regard to the software products. (iii) The Customer shall be entitled to transfer the right of use granted hereunder to a third party, provided that such third party agrees to the continued validity of the rights of use for and in relation with the PI Hardware and that the Customer deletes any remaining copies of the Software without undue delay. Such a third party shall not be granted any rights of use beyond the rights of use granted to the Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party uses the Software in accordance with these Terms and Conditions and in particular solely for the purpose of operating the PI Hardware. Subparagraph (xii) shall remain unaffected. (iv) The subleasing of the Software for commercial purposes is prohibited. (v) The Customer shall not grant any sublicenses of the Software, unless stipulated otherwise in these Terms and Conditions. (vi) The Customer shall not be entitled to modify, extend, reverse engineer, decompile, reverse assemble or disassemble Software delivered in machine-readable form (object code) unless it is necessary for the purpose of using the Software in accordance with its contractually agreed or contractually intended purpose, including the purpose of removing defects, or unless it is specifically permitted by law, particularly according to section 69a et sqq. of the German Copyright Act (UrhG), in any case only if PI does not provide the Customer with the required information or does not remove the defect within a reasonable period of time after having been requested to do so via an email sent by the Customer to support-software@pi.ws. (vii) If the Software or parts thereof are provided together with its source code, the Customer shall be entitled to modify the Software on the basis of the source code and to use the modified source code solely for the purpose of operating the PI Hardware and/or third-party systems that include the PI Hardware in accordance with these Terms and Conditions; provided, however, that the Customer shall always include in any such modification a brief summary of the changes made to the source code and the date of the modification. Subject to clause IV, PI shall not be held responsible for any claims resulting from such modification of the source code. (viii) Copyright notes, serial numbers as well as further characteristics for identification shall not be removed from the Software and copies thereof. (ix) PI may provide the Customer with Software which includes or may be used together with third-party software (including freeware and open source software components). PI informs the Customer about the third-party software used and provides the Customer with the corresponding license terms within the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf) to the extent requested by the respective licensor. With regard to third-party software listed in the Third Party Software Note, the respective license terms, which the third-party software is subject to, shall apply. In case of a breach of the third-party license terms, the respective licensor may also be entitled to make subsequent claims and rights in its own name. (x) If PI provides the Customer with amendments (patches, bug fixes, amendments to the manual etc.) or a new edition (updates, upgrades) of the Software within the scope of rectification or maintenance, which replace the originally provided Software, those are subject to these Terms and Conditions. (xi) In the event that PI provides the Customer with a test version of the Software, these Terms and Conditions apply accordingly, however, except that the Customer is granted with a right to use the Software, which is limited to the defined test period. (xii) A temporary use of the Software by a third person, who integrates the Software and PI Hardware with other products on behalf of the Customer, is considered as use by the Customer's company. Such third party shall use the Software only within the time period required for the integration or for providing support services to the Customer and shall be bound in accordance with the contractual obligations under these Terms and Conditions. III. Rectification in case of defects (1) Definitions (i) The Software shall be deemed as defective in quality in the event that it does not show the contractually stipulated condition or it does not fit the contractually stipulated purpose. (ii) The Software is subject to proprietary rights (particularly copyrights) of PI and/or third parties. It constitutes a defect in title if required rights for the contract-based usage could not be legally granted to the Customer. (2) Statute of limitations (i) The statute of limitations for claims of defects is 12 months, calculated from the date of the delivery of the Software. (ii) This does not apply in the event of actions of PI or its representatives or vicarious agents (Erfuellungsgehilfen) in bad faith or in relation to guarantees granted. (3) Modifications to the Software by the Customer As far as the Customer modifies the Software or has it modified by third parties, claims regarding defects in quality or title shall be invalidated, unless the Customer proofs that the defect was not caused by the modifications and also if the analysis and the removal of the defect is not affected by the modification. (4) Obligations to examine and notify defects (i) After delivery of the Software to the Customer, the Customer shall examine the Software for completeness and possible defects without undue delay, insofar as this is feasible in the orderly course of business, and notify PI immediately of any complaints. Otherwise, claims of the Customer as defined in the following clauses shall be excluded in relation to such defects in quality that would have been obvious within a properly conducted examination. (ii) Together with the notification of the defect, the Customer has to provide PI with comprehensible documentation thereof. (5) Supplementary performance (Nacherfuellung) (i) PI may rectify the defect by reworking the Software (Nachbesserung) or by supplying a replacement, as it chooses. The Customer may request within a reasonable time period a reworking or a supply of a replacement of the Software, if another type of supplementary performance is unreasonable. (ii) Alternatively, PI can rectify the defect by providing instructions electronically, by phone, in writing or by providing updates for download on its homepage to the Customer. (6) Measures in the event of alleged defects in title (i) Should a third party raise claims against the Customer based on the allegation that the Software or the designation of the Software infringes its intellectual property rights, the Customer will notify PI immediately thereof and entrust PI with the defense against the alleged claims as far as possible. The Customer will provide to PI any reasonable support in this regard. (ii) PI can remedy a defect in title by providing the Customer with a legally unchallengeable option to use either the Software or a legally unchallengeable modification of the Software, at its sole discretion. If not stipulated otherwise, the regulations of this clause also remain applicable equivalently in relations to defects in title. (7) PI shall provide its services subject to the supplementary performance within a reasonable period. (8) Bad faith (Arglist), guarantees Statutory claims of the Customer remain unaffected in case of actions of PI or its representatives or vicarious agents in bad faith or in relation to guarantees granted. The stipulations of clause IV shall remain unaffected by this clause III. IV. Limitation of Liability PI only assumes liability under the following conditions: (1) For damage caused by PI or any of its legal representatives, executive staff or vicarious agents through willful intent or gross negligence, PI is liable without restriction. (2) PI is not liable for any violation of insignificant contractual obligations by minor negligence. With regard to a violation of essential contractual obligations (i.e. obligations which the contractual partner can expect to be fulfilled and the fulfilment of which is required for the due execution of the contract) PI's liability for damage caused by minor negligence is limited to anticipated damage typical to contracts of this kind (vertragstypisch vorhersehbare Schaeden). The same applies to violations of obligations through minor negligence committed by legal representatives, executive staff or vicarious agents of PI. (3) No license fee is charged to the Customer by PI for the use of any open source or freeware software component / product. Regarding such components / products, the Customer hereby accepts the application of the corresponding license terms which are attached in the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf). To the extent that there is a conflict between these Terms and Conditions and the respective license terms, the license terms shall prevail over these Terms and Conditions with regard to the respective open source or freeware software component / product. However, PI's liability for willful intent and gross negligence remains unaffected. (4) Notwithstanding the foregoing, contributory negligence of the Client diminishes the amount of any claims for damages, especially if caused by insufficient cooperation, organizational errors, insufficient data protection or a breach of other contractual duties. (5) The Customer is responsible to back up his data regularly. In the event of a loss of data caused by PI, the liability of PI is limited to the costs of reproducing the lost data on the basis of the backups that the Customer was under the obligation to conduct and for costs for reproducing data that would have been also lost, even if the Customer had conducted regular backups. (6) The aforementioned limitation of liability does not apply in the event of fraudulent intent, injury to life, body and health, breach of warranty, and claims based on the German Product Liability Act (ProduktHaftG). V. Final Provisions (1) The place of performance for deliveries shall be the registered office (Sitz) of PI. (2) The district court of Karlsruhe (Landgericht Karlsruhe) shall have jurisdiction over all disputes arising from or in connection with these Terms and Conditions. PI shall, however, be entitled to assert claims at the registered seat of the Customer. (3) The laws of Germany shall apply. International purchase laws shall not apply. This shall, in particular, refer to the UN Convention (CISG) on the International Sale of Goods. (4) The invalidity or unenforceability of any provision of these Terms and Conditions shall not affect the validity and enforceability of the other provisions. Invalid or unenforceable provisions shall be deemed to be replaced by such valid and enforceable provisions that shall be suitable to implement the economic purpose of the deleted provision to the greatest extent possible. The same applies for omissions.","title":"EULA"},{"location":"eula.html#license-agreement","text":"General Software License Agreement of Physik Instrumente (PI) GmbH & Co. KG Issued: April 16, 2018","title":"License Agreement"},{"location":"eula.html#preamble","text":"Physik Instrumente (PI) GmbH & Co. KG (hereinafter referred to as \"PI\") is a manufacturer and provider of micro- and nanopositioning technology and motion control systems, devices and apparatuses including their respective firmware (hereinafter jointly referred to as \"the PI Hardware\"), which can either be used independently or as an integral part of other third-party hardware systems. For the purpose of operating the PI Hardware, PI provides its customers, which either purchase the PI Hardware directly from PI for their own use or which integrate the PI Hardware into third-party hardware systems for distribution to their clients (hereinafter jointly referred to as \"the Customer\") with software products or tools (hereinafter jointly referred to as \"the Software\"). The following general terms and conditions (hereinafter referred to as \"Terms and Conditions\") shall apply to any Software provided by PI to the Customer, unless expressly agreed or stated otherwise herein, and may be supplemented by specific terms and conditions for individual software components.","title":"Preamble"},{"location":"eula.html#i-scope","text":"(1) These Terms and Conditions shall apply to the supply of Software for its use together with PI Hardware and the granting of rights of use to the Customer, as described below. (2) The Software is supplied by PI to the Customer either in machine-readable form or with regard to certain software components in machine-readable form together with its source code and is subject to the following Terms and Conditions, unless PI and the Customer have agreed otherwise in writing. (3) These Terms and Conditions shall not apply to the PI Hardware. (4) PI does not owe any installation and configuration services under these Terms and Conditions. (5) The Software is not designed for use in medical devices (Medizinprodukt) according to section 3 of the German Act on Medical Devices (MPG). (6) References to the application of statutory provisions only serve clarification purposes. Therefore, the statutory provisions apply even without such clarification, unless modified directly by these Terms and Conditions.","title":"I. Scope"},{"location":"eula.html#ii-rights-of-use","text":"(1) Unless stated otherwise herein, PI grants to the Customer a non-exclusive territorially unrestricted right to use the Software for an unlimited period of time on the basis of the following provisions. (2) The following restrictions apply, if not explicitly agreed otherwise: (i) The Customer shall be entitled to use the Software insofar as this is required for the contractually agreed or contractually intended use of the Software and in accordance with these Terms and Conditions, including the right to install the Software onto a hard disk drive and/or to load it into the random access memory (RAM). If not specified otherwise, the Customer is entitled to use the Software within its company on several devices or on several workstations simultaneously and to duplicate the Software for that purpose. In the event that the use of the Software depends on a prior activation and is therefore limited to a certain license key (to be individually purchased by the Customer from PI), the use of the affected Software shall however be restricted to the respective device for which the Software has been activated by the Customer. The Software shall in any case be used by the Customer exclusively for and in relation with the operation of PI Hardware. The Customer shall insofar however be entitled to use the Software together with third-party software or to combine the Software with third-party software products, as far as necessary to operate its or any third-party systems that do include the PI Hardware. (ii) The Customer shall furthermore be entitled to generate application-specific, loadable and executable software products with the Software and to transfer such software products to third parties only for use for and in relation with the operation of PI Hardware. Such third party shall not be granted any rights of use beyond the rights of use granted to Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party shall be bound by the contractual obligations under these Terms and Conditions with regard to the software products. (iii) The Customer shall be entitled to transfer the right of use granted hereunder to a third party, provided that such third party agrees to the continued validity of the rights of use for and in relation with the PI Hardware and that the Customer deletes any remaining copies of the Software without undue delay. Such a third party shall not be granted any rights of use beyond the rights of use granted to the Customer under these Terms and Conditions. Moreover, the Customer shall contractually ensure that such third party uses the Software in accordance with these Terms and Conditions and in particular solely for the purpose of operating the PI Hardware. Subparagraph (xii) shall remain unaffected. (iv) The subleasing of the Software for commercial purposes is prohibited. (v) The Customer shall not grant any sublicenses of the Software, unless stipulated otherwise in these Terms and Conditions. (vi) The Customer shall not be entitled to modify, extend, reverse engineer, decompile, reverse assemble or disassemble Software delivered in machine-readable form (object code) unless it is necessary for the purpose of using the Software in accordance with its contractually agreed or contractually intended purpose, including the purpose of removing defects, or unless it is specifically permitted by law, particularly according to section 69a et sqq. of the German Copyright Act (UrhG), in any case only if PI does not provide the Customer with the required information or does not remove the defect within a reasonable period of time after having been requested to do so via an email sent by the Customer to support-software@pi.ws. (vii) If the Software or parts thereof are provided together with its source code, the Customer shall be entitled to modify the Software on the basis of the source code and to use the modified source code solely for the purpose of operating the PI Hardware and/or third-party systems that include the PI Hardware in accordance with these Terms and Conditions; provided, however, that the Customer shall always include in any such modification a brief summary of the changes made to the source code and the date of the modification. Subject to clause IV, PI shall not be held responsible for any claims resulting from such modification of the source code. (viii) Copyright notes, serial numbers as well as further characteristics for identification shall not be removed from the Software and copies thereof. (ix) PI may provide the Customer with Software which includes or may be used together with third-party software (including freeware and open source software components). PI informs the Customer about the third-party software used and provides the Customer with the corresponding license terms within the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf) to the extent requested by the respective licensor. With regard to third-party software listed in the Third Party Software Note, the respective license terms, which the third-party software is subject to, shall apply. In case of a breach of the third-party license terms, the respective licensor may also be entitled to make subsequent claims and rights in its own name. (x) If PI provides the Customer with amendments (patches, bug fixes, amendments to the manual etc.) or a new edition (updates, upgrades) of the Software within the scope of rectification or maintenance, which replace the originally provided Software, those are subject to these Terms and Conditions. (xi) In the event that PI provides the Customer with a test version of the Software, these Terms and Conditions apply accordingly, however, except that the Customer is granted with a right to use the Software, which is limited to the defined test period. (xii) A temporary use of the Software by a third person, who integrates the Software and PI Hardware with other products on behalf of the Customer, is considered as use by the Customer's company. Such third party shall use the Software only within the time period required for the integration or for providing support services to the Customer and shall be bound in accordance with the contractual obligations under these Terms and Conditions.","title":"II. Rights of Use"},{"location":"eula.html#iii-rectification-in-case-of-defects","text":"(1) Definitions (i) The Software shall be deemed as defective in quality in the event that it does not show the contractually stipulated condition or it does not fit the contractually stipulated purpose. (ii) The Software is subject to proprietary rights (particularly copyrights) of PI and/or third parties. It constitutes a defect in title if required rights for the contract-based usage could not be legally granted to the Customer. (2) Statute of limitations (i) The statute of limitations for claims of defects is 12 months, calculated from the date of the delivery of the Software. (ii) This does not apply in the event of actions of PI or its representatives or vicarious agents (Erfuellungsgehilfen) in bad faith or in relation to guarantees granted. (3) Modifications to the Software by the Customer As far as the Customer modifies the Software or has it modified by third parties, claims regarding defects in quality or title shall be invalidated, unless the Customer proofs that the defect was not caused by the modifications and also if the analysis and the removal of the defect is not affected by the modification. (4) Obligations to examine and notify defects (i) After delivery of the Software to the Customer, the Customer shall examine the Software for completeness and possible defects without undue delay, insofar as this is feasible in the orderly course of business, and notify PI immediately of any complaints. Otherwise, claims of the Customer as defined in the following clauses shall be excluded in relation to such defects in quality that would have been obvious within a properly conducted examination. (ii) Together with the notification of the defect, the Customer has to provide PI with comprehensible documentation thereof. (5) Supplementary performance (Nacherfuellung) (i) PI may rectify the defect by reworking the Software (Nachbesserung) or by supplying a replacement, as it chooses. The Customer may request within a reasonable time period a reworking or a supply of a replacement of the Software, if another type of supplementary performance is unreasonable. (ii) Alternatively, PI can rectify the defect by providing instructions electronically, by phone, in writing or by providing updates for download on its homepage to the Customer. (6) Measures in the event of alleged defects in title (i) Should a third party raise claims against the Customer based on the allegation that the Software or the designation of the Software infringes its intellectual property rights, the Customer will notify PI immediately thereof and entrust PI with the defense against the alleged claims as far as possible. The Customer will provide to PI any reasonable support in this regard. (ii) PI can remedy a defect in title by providing the Customer with a legally unchallengeable option to use either the Software or a legally unchallengeable modification of the Software, at its sole discretion. If not stipulated otherwise, the regulations of this clause also remain applicable equivalently in relations to defects in title. (7) PI shall provide its services subject to the supplementary performance within a reasonable period. (8) Bad faith (Arglist), guarantees Statutory claims of the Customer remain unaffected in case of actions of PI or its representatives or vicarious agents in bad faith or in relation to guarantees granted. The stipulations of clause IV shall remain unaffected by this clause III.","title":"III. Rectification in case of defects"},{"location":"eula.html#iv-limitation-of-liability","text":"PI only assumes liability under the following conditions: (1) For damage caused by PI or any of its legal representatives, executive staff or vicarious agents through willful intent or gross negligence, PI is liable without restriction. (2) PI is not liable for any violation of insignificant contractual obligations by minor negligence. With regard to a violation of essential contractual obligations (i.e. obligations which the contractual partner can expect to be fulfilled and the fulfilment of which is required for the due execution of the contract) PI's liability for damage caused by minor negligence is limited to anticipated damage typical to contracts of this kind (vertragstypisch vorhersehbare Schaeden). The same applies to violations of obligations through minor negligence committed by legal representatives, executive staff or vicarious agents of PI. (3) No license fee is charged to the Customer by PI for the use of any open source or freeware software component / product. Regarding such components / products, the Customer hereby accepts the application of the corresponding license terms which are attached in the Third Party Software Note (http://www.physikinstrumente.com/download/TPSWNote_PhysikInstrumenteGmbH_Co_KG.pdf). To the extent that there is a conflict between these Terms and Conditions and the respective license terms, the license terms shall prevail over these Terms and Conditions with regard to the respective open source or freeware software component / product. However, PI's liability for willful intent and gross negligence remains unaffected. (4) Notwithstanding the foregoing, contributory negligence of the Client diminishes the amount of any claims for damages, especially if caused by insufficient cooperation, organizational errors, insufficient data protection or a breach of other contractual duties. (5) The Customer is responsible to back up his data regularly. In the event of a loss of data caused by PI, the liability of PI is limited to the costs of reproducing the lost data on the basis of the backups that the Customer was under the obligation to conduct and for costs for reproducing data that would have been also lost, even if the Customer had conducted regular backups. (6) The aforementioned limitation of liability does not apply in the event of fraudulent intent, injury to life, body and health, breach of warranty, and claims based on the German Product Liability Act (ProduktHaftG).","title":"IV. Limitation of Liability"},{"location":"eula.html#v-final-provisions","text":"(1) The place of performance for deliveries shall be the registered office (Sitz) of PI. (2) The district court of Karlsruhe (Landgericht Karlsruhe) shall have jurisdiction over all disputes arising from or in connection with these Terms and Conditions. PI shall, however, be entitled to assert claims at the registered seat of the Customer. (3) The laws of Germany shall apply. International purchase laws shall not apply. This shall, in particular, refer to the UN Convention (CISG) on the International Sale of Goods. (4) The invalidity or unenforceability of any provision of these Terms and Conditions shall not affect the validity and enforceability of the other provisions. Invalid or unenforceable provisions shall be deemed to be replaced by such valid and enforceable provisions that shall be suitable to implement the economic purpose of the deleted provision to the greatest extent possible. The same applies for omissions.","title":"V. Final Provisions"},{"location":"history.html","text":"Feature Version History PIPython 2.2.2 fix: No module named gcs21.gcs21commands_helpers PIPython 2.2.1 fix missing argument in isgcs21 PIPython 2.2.0 Support for PI_SetConnectTimeout() and PI_EnableBaudRateScan() PIPython 2.1.1 fix timing probles while reading the data recorder with pythom3 PIPython 2.1.0 pipython.datarectools.Datarecorder: maxnumvalues now also reads the maximum number of data recorder points from the 'HDR?' answer. fix pipython.pitools.pitoopls.itemstostr. If 'data' is an integer of 0 or a float of 0.0 'itemstostr' now returns the string '0' or '0.0' instead of 'None' PIPython 2.0.0 New package structure support for WriteConfigurationFromDatabaseToControllerAndSave() PIPython 1.5.2 Linux: fix string decoding in piusb PIPython 1.5.1 fix parameter value conversion of hex parameter values PIPython 1.5.0 add GCSCommands.POL() add GCSCommands.STD() add GCSCommands.RTD() add GCSCommands.qRTD() add GCSCommands.qLST() add GCSCommands.DTL() PIPython 1.4.0 fix string decoding in GCSDll() add pitools.getservo() pitools.waitonreferencing() does not call waitontarget() in pitools call waitonready() with the \"polldelay\" argument fix signature of GCSCommands.qTWS() GCSCommands.CCL() will reset the list of supported GCS commands interfaces.pisocket.PISocket() uses socket.TCP_NODELAY add \"ATZ\" as \"referencing command\" to pitools.DeviceStartup() add GCSMessages.logfile property rename license.md to eula.md add datarectools.get_hdr_options() add Datarecorder.recopts property add Datarecorder.trigopts property all timeout default values are set to 300 seconds PIPython 1.3.9 add pitools.waitonmacro() catch GCS error 2 (unknown command) after EAX during startup GCS commands arguments can be sets, too DDL(tables, offsets, values) -> DDL(table, offsets, values) add GCSDevice.isavailable convert parameter values according to types in qHPA answer fix signature of GCSCommands.qJLT() PIPython 1.3.8 add interfaces.piusb add pitools.readgcsarray() add pitools.waitonwavegen() add pitools.moveandwait() add piparams.applyconfig() pitools.startup() defines and references stages only if necessary add GCSCommands.allaxes add GCSDevice.hasref() add GCSDevice.haslim() add GCSDevice.canfrf() add GCSDevice.canfnl() add GCSDevice.canfpl() add pitools.waitonphase() add pitools.setservo() controller specific startup sequence PIPython 1.3.7 add pitools.movetomiddle() add pipython.fastaligntools PI_GCS2_DLL is used by default add pitools.savegcsarray() add pitools.itemstostr() PIPython 1.3.6 add controller C-886, E-872 GCSDevice supports external Gateway PIPython 1.3.5 add DLL functions for PIStages3 \"wait on\" functions support polldelay times fix GCSCommands.SGA() fix GCSCommands.qSPA() fix GCSCommands.qSEP() add optional argument \"noraise\" for StopAll(), HLT(), STP() add pitools.waitonfastalign() add pitools.waitonautozero() add GCS Error codes PIPython 1.3.4 add pipython.interfaces.piserial \"wait on\" functions support predelay and postdelay times add GCSCommands.TSP() setup writes key for PIUpdateFinder always into 32 bit part of registry change formatting of numbers in GCS strings GCSDll supports \"K\" devices GCSMessages.bufstate will not write to log rename ReadGCSData() -> read_gcsdata() add controller C-663.12 add parameters for E-873.3QTU, C-663.10C885 add GCS Error codes bugfixing PIPython 1.3.3 add GCSCommands.SGP() add GCSCommands.qSGP() add GCSCommands.WAV_SIN() add GCSCommands.WAV_POL() add GCSCommands.WAV_TAN() add GCSCommands.WAV_SWEEP() add GCSCommands.checkerror() add GCSCommands.DEL() add new controllers add controller parameters fix for handling unicode in Python 3 bugfixing of some GCS commands PIPython 1.3.2 add GCSCommands.FSF() add GCSCommands.qFSF() add GCSCommands.qFSR() add pitools.getaxeslist() add pitools.ontarget() add pitools.waitonwalk() add pitools.waitonoma() add pitools.waitontrajectory() fix DLL function prefix","title":"History"},{"location":"history.html#feature-version-history","text":"","title":"Feature Version History"},{"location":"history.html#pipython-222","text":"fix: No module named gcs21.gcs21commands_helpers","title":"PIPython 2.2.2"},{"location":"history.html#pipython-221","text":"fix missing argument in isgcs21","title":"PIPython 2.2.1"},{"location":"history.html#pipython-220","text":"Support for PI_SetConnectTimeout() and PI_EnableBaudRateScan()","title":"PIPython 2.2.0"},{"location":"history.html#pipython-211","text":"fix timing probles while reading the data recorder with pythom3","title":"PIPython 2.1.1"},{"location":"history.html#pipython-210","text":"pipython.datarectools.Datarecorder: maxnumvalues now also reads the maximum number of data recorder points from the 'HDR?' answer. fix pipython.pitools.pitoopls.itemstostr. If 'data' is an integer of 0 or a float of 0.0 'itemstostr' now returns the string '0' or '0.0' instead of 'None'","title":"PIPython 2.1.0"},{"location":"history.html#pipython-200","text":"New package structure support for WriteConfigurationFromDatabaseToControllerAndSave()","title":"PIPython 2.0.0"},{"location":"history.html#pipython-152","text":"Linux: fix string decoding in piusb","title":"PIPython 1.5.2"},{"location":"history.html#pipython-151","text":"fix parameter value conversion of hex parameter values","title":"PIPython 1.5.1"},{"location":"history.html#pipython-150","text":"add GCSCommands.POL() add GCSCommands.STD() add GCSCommands.RTD() add GCSCommands.qRTD() add GCSCommands.qLST() add GCSCommands.DTL()","title":"PIPython 1.5.0"},{"location":"history.html#pipython-140","text":"fix string decoding in GCSDll() add pitools.getservo() pitools.waitonreferencing() does not call waitontarget() in pitools call waitonready() with the \"polldelay\" argument fix signature of GCSCommands.qTWS() GCSCommands.CCL() will reset the list of supported GCS commands interfaces.pisocket.PISocket() uses socket.TCP_NODELAY add \"ATZ\" as \"referencing command\" to pitools.DeviceStartup() add GCSMessages.logfile property rename license.md to eula.md add datarectools.get_hdr_options() add Datarecorder.recopts property add Datarecorder.trigopts property all timeout default values are set to 300 seconds","title":"PIPython 1.4.0"},{"location":"history.html#pipython-139","text":"add pitools.waitonmacro() catch GCS error 2 (unknown command) after EAX during startup GCS commands arguments can be sets, too DDL(tables, offsets, values) -> DDL(table, offsets, values) add GCSDevice.isavailable convert parameter values according to types in qHPA answer fix signature of GCSCommands.qJLT()","title":"PIPython 1.3.9"},{"location":"history.html#pipython-138","text":"add interfaces.piusb add pitools.readgcsarray() add pitools.waitonwavegen() add pitools.moveandwait() add piparams.applyconfig() pitools.startup() defines and references stages only if necessary add GCSCommands.allaxes add GCSDevice.hasref() add GCSDevice.haslim() add GCSDevice.canfrf() add GCSDevice.canfnl() add GCSDevice.canfpl() add pitools.waitonphase() add pitools.setservo() controller specific startup sequence","title":"PIPython 1.3.8"},{"location":"history.html#pipython-137","text":"add pitools.movetomiddle() add pipython.fastaligntools PI_GCS2_DLL is used by default add pitools.savegcsarray() add pitools.itemstostr()","title":"PIPython 1.3.7"},{"location":"history.html#pipython-136","text":"add controller C-886, E-872 GCSDevice supports external Gateway","title":"PIPython 1.3.6"},{"location":"history.html#pipython-135","text":"add DLL functions for PIStages3 \"wait on\" functions support polldelay times fix GCSCommands.SGA() fix GCSCommands.qSPA() fix GCSCommands.qSEP() add optional argument \"noraise\" for StopAll(), HLT(), STP() add pitools.waitonfastalign() add pitools.waitonautozero() add GCS Error codes","title":"PIPython 1.3.5"},{"location":"history.html#pipython-134","text":"add pipython.interfaces.piserial \"wait on\" functions support predelay and postdelay times add GCSCommands.TSP() setup writes key for PIUpdateFinder always into 32 bit part of registry change formatting of numbers in GCS strings GCSDll supports \"K\" devices GCSMessages.bufstate will not write to log rename ReadGCSData() -> read_gcsdata() add controller C-663.12 add parameters for E-873.3QTU, C-663.10C885 add GCS Error codes bugfixing","title":"PIPython 1.3.4"},{"location":"history.html#pipython-133","text":"add GCSCommands.SGP() add GCSCommands.qSGP() add GCSCommands.WAV_SIN() add GCSCommands.WAV_POL() add GCSCommands.WAV_TAN() add GCSCommands.WAV_SWEEP() add GCSCommands.checkerror() add GCSCommands.DEL() add new controllers add controller parameters fix for handling unicode in Python 3 bugfixing of some GCS commands","title":"PIPython 1.3.3"},{"location":"history.html#pipython-132","text":"add GCSCommands.FSF() add GCSCommands.qFSF() add GCSCommands.qFSR() add pitools.getaxeslist() add pitools.ontarget() add pitools.waitonwalk() add pitools.waitonoma() add pitools.waitontrajectory() fix DLL function prefix","title":"PIPython 1.3.2"},{"location":"mainpage.html","text":"PIPython is a collection of Python modules to access a PI device and process GCS data. It can be used with Python 2.7+ and 3.4+ on Windows, Linux and OSX and without the use of the GCS DLL also on any other platform. Quickstart Communicate to a PI device via GCSDevice which wraps the GCS DLL functions and provides methods to connect to the device. Usually you call GCSDevice without an argument. from pipython import GCSDevice gcs = GCSDevice() gcs.ConnectTCPIP('192.168.90.112') # you may change the IP address # gcs.ConnectUSB('1234567890') # you may change the serial number # gcs.ConnectRS232(1, 115200) # you may change the COM port and baudrate print(gcs.qIDN()) gcs.CloseConnection() Only for some older controllers that do not use the PI_GCS2_DLL you have to pass the controller name as argument. from pipython import GCSDevice gcs = GCSDevice('C-843') gcs.ConnectPciBoard(1) # you may change the PCI board number print(gcs.qIDN()) gcs.CloseConnection() It's recommended to use GCSDevice as a context manager which closes the connection if an exception raises inside the with statement. from pipython import GCSDevice with GCSDevice() as gcs: gcs.InterfaceSetupDlg() # interactive dialog to choose the interface print(gcs.qIDN()) See also the provided samples in the samples subdirectory. Start with quickstart.py . Requirements There are no dependencies to additional packages. With pipython.interfaces.piusb you can connect a USB device without using the GCS DLL. This works only on Linux systems and requires LibUSB which usually is provided by the OS. Arguments From now on gcs refers to a connected GCSDevice instance. Usually you can call a setter function with - a dictionary of axes/channels and values - a list for axes/channels and a list of the values - a single item for axis/channel and a single value gcs.MOV({'X': 1.23, 'Y': 2.34}) gcs.MOV(['X', 'Y'], [1.23, 2.34]) gcs.MOV('X', 1.23) For channels and numeric axis names you can omit the quotes. gcs.MOV({1: 1.23, 2: 2.34}) gcs.MOV([1, 2], [1.23, 2.34]) gcs.MOV(1, 1.23) Usually getter commands can be called with - a list of axes/channels - a single item for axis/channel, without quotes if numeric - without any arguments which will return the answer for all available axes/channels gcs.qPOS(['X', 'Y']) gcs.qPOS('X') gcs.qPOS(1) gcs.qPOS() Return values Axes or channel related answers are returned as (ordered) dictionary. gcs.qPOS() >>>{'X': 1.23, 'Y': 2.34} If you provide arguments their types are preserved and you can use these as keys. pos = gcs.qPOS([1, 2, 3]) print(pos[1]) If you do not provide arguments you always have to use strings as keys. pos = gcs.qPOS() print(pos['1']) The following sample will move all axes to targets and waits until the motion has finished. It shows how to use only the values from the returned dictionary. from time import sleep ... gcs.MOV(axes, targets) while not all(gcs.qONT(axes).values()): sleep(0.1) Some hints... Helpers In pipython.pitools you will find some helper funtions for your convenience. See the docstrings and the provided samples for how to use them. The sample above can then be written as: import pipython.pitools as pi ... gcs.MOV(axes, targets) pi.waitontarget(gcs, axes) Enable debug logging To log debug messages on the console just enter these lines prior to calling GCSDevice . from logging import basicConfig, DEBUG basicConfig(level=DEBUG) There is also a property to log the communication data to a text file. gcs.logfile = 'commandlog.txt' GCSError and error check By default an \"ERR?\" command is sent after each command to query if an error occurred on the device which then will be raised as GCSError exception. If communication speed is an issue you can disable error checking. gcs.errcheck = False To handle a catched GCSError exception you can use the defines provided by gcserror instead of pure numeric values. Remember the difference between GCSError which is the exception class and gcserror which is the according module. from pipython import GCSDevice, GCSError, gcserror with GCSDevice() as gcs: try: gcs.MOV('X', 1.23) except GCSError as exc: if exc == gcserror.E_1024_PI_MOTION_ERROR: print 'There was a motion error, please check the mechanics.' else: raise The exception class GCSError will translate the error code into a readable message. from pipython import GCSError, gcserror raise GCSError(gcserror.E_1024_PI_MOTION_ERROR) >>>GCSError: Motion error: position error too large, servo is switched off automatically (-1024) With the property GCSDevice.embederr you can embed the error querying command into a GCS set command. Hence only one package needs to be sent to the device which also can improve communication performance. Big data Commands like qDRR() which read a large amount of GCS data return immediately with the header dictionary containing information about the data. Then they will start a background task that carries on reading data from the device into an internal buffer. The bufstate property returns the progress of the reading as floating point number in the range 0 to 1 and turns to True when reading has finished. Hence, when using it in a loop check for is not True . (Remember, this is not the same as != True .) header = gcs.qDRR(tables=1, offset=1, numvalues=8192) while gcs.bufstate is not True: print('read data {:.1f}%...'.format(gcs.bufstate * 100)) sleep(0.1) data = gcs.bufdata Textual interface Besides the functions implemented in GCSCommands you can send GCS commands as strings to the controller. Use read() for commands returning an answer, read_gcsdata() for commands returning GCS data and send() for non-answering commands. print gcs.read('POS?') print gcs.read_gcsdata('DRR? 1 100 1') gcs.send('MOV X 1.23') They return the raw string or GCS data from the controller. If errorcheck is enabled the error state is queried from the device automatically. It's recommended to use the provided functions instead of sending raw strings. In line with the C++ GCS DLL the functions ReadGCSCommand() and GcsCommandset() are also available. They will never query an error from the device. print gcs.ReadGCSCommand('POS?') gcs.GcsCommandset('MOV X 1.23')","title":"Mainpage"},{"location":"mainpage.html#quickstart","text":"Communicate to a PI device via GCSDevice which wraps the GCS DLL functions and provides methods to connect to the device. Usually you call GCSDevice without an argument. from pipython import GCSDevice gcs = GCSDevice() gcs.ConnectTCPIP('192.168.90.112') # you may change the IP address # gcs.ConnectUSB('1234567890') # you may change the serial number # gcs.ConnectRS232(1, 115200) # you may change the COM port and baudrate print(gcs.qIDN()) gcs.CloseConnection() Only for some older controllers that do not use the PI_GCS2_DLL you have to pass the controller name as argument. from pipython import GCSDevice gcs = GCSDevice('C-843') gcs.ConnectPciBoard(1) # you may change the PCI board number print(gcs.qIDN()) gcs.CloseConnection() It's recommended to use GCSDevice as a context manager which closes the connection if an exception raises inside the with statement. from pipython import GCSDevice with GCSDevice() as gcs: gcs.InterfaceSetupDlg() # interactive dialog to choose the interface print(gcs.qIDN()) See also the provided samples in the samples subdirectory. Start with quickstart.py .","title":"Quickstart"},{"location":"mainpage.html#requirements","text":"There are no dependencies to additional packages. With pipython.interfaces.piusb you can connect a USB device without using the GCS DLL. This works only on Linux systems and requires LibUSB which usually is provided by the OS.","title":"Requirements"},{"location":"mainpage.html#arguments","text":"From now on gcs refers to a connected GCSDevice instance. Usually you can call a setter function with - a dictionary of axes/channels and values - a list for axes/channels and a list of the values - a single item for axis/channel and a single value gcs.MOV({'X': 1.23, 'Y': 2.34}) gcs.MOV(['X', 'Y'], [1.23, 2.34]) gcs.MOV('X', 1.23) For channels and numeric axis names you can omit the quotes. gcs.MOV({1: 1.23, 2: 2.34}) gcs.MOV([1, 2], [1.23, 2.34]) gcs.MOV(1, 1.23) Usually getter commands can be called with - a list of axes/channels - a single item for axis/channel, without quotes if numeric - without any arguments which will return the answer for all available axes/channels gcs.qPOS(['X', 'Y']) gcs.qPOS('X') gcs.qPOS(1) gcs.qPOS()","title":"Arguments"},{"location":"mainpage.html#return-values","text":"Axes or channel related answers are returned as (ordered) dictionary. gcs.qPOS() >>>{'X': 1.23, 'Y': 2.34} If you provide arguments their types are preserved and you can use these as keys. pos = gcs.qPOS([1, 2, 3]) print(pos[1]) If you do not provide arguments you always have to use strings as keys. pos = gcs.qPOS() print(pos['1']) The following sample will move all axes to targets and waits until the motion has finished. It shows how to use only the values from the returned dictionary. from time import sleep ... gcs.MOV(axes, targets) while not all(gcs.qONT(axes).values()): sleep(0.1)","title":"Return values"},{"location":"mainpage.html#some-hints","text":"","title":"Some hints..."},{"location":"mainpage.html#helpers","text":"In pipython.pitools you will find some helper funtions for your convenience. See the docstrings and the provided samples for how to use them. The sample above can then be written as: import pipython.pitools as pi ... gcs.MOV(axes, targets) pi.waitontarget(gcs, axes)","title":"Helpers"},{"location":"mainpage.html#enable-debug-logging","text":"To log debug messages on the console just enter these lines prior to calling GCSDevice . from logging import basicConfig, DEBUG basicConfig(level=DEBUG) There is also a property to log the communication data to a text file. gcs.logfile = 'commandlog.txt'","title":"Enable debug logging"},{"location":"mainpage.html#gcserror-and-error-check","text":"By default an \"ERR?\" command is sent after each command to query if an error occurred on the device which then will be raised as GCSError exception. If communication speed is an issue you can disable error checking. gcs.errcheck = False To handle a catched GCSError exception you can use the defines provided by gcserror instead of pure numeric values. Remember the difference between GCSError which is the exception class and gcserror which is the according module. from pipython import GCSDevice, GCSError, gcserror with GCSDevice() as gcs: try: gcs.MOV('X', 1.23) except GCSError as exc: if exc == gcserror.E_1024_PI_MOTION_ERROR: print 'There was a motion error, please check the mechanics.' else: raise The exception class GCSError will translate the error code into a readable message. from pipython import GCSError, gcserror raise GCSError(gcserror.E_1024_PI_MOTION_ERROR) >>>GCSError: Motion error: position error too large, servo is switched off automatically (-1024) With the property GCSDevice.embederr you can embed the error querying command into a GCS set command. Hence only one package needs to be sent to the device which also can improve communication performance.","title":"GCSError and error check"},{"location":"mainpage.html#big-data","text":"Commands like qDRR() which read a large amount of GCS data return immediately with the header dictionary containing information about the data. Then they will start a background task that carries on reading data from the device into an internal buffer. The bufstate property returns the progress of the reading as floating point number in the range 0 to 1 and turns to True when reading has finished. Hence, when using it in a loop check for is not True . (Remember, this is not the same as != True .) header = gcs.qDRR(tables=1, offset=1, numvalues=8192) while gcs.bufstate is not True: print('read data {:.1f}%...'.format(gcs.bufstate * 100)) sleep(0.1) data = gcs.bufdata","title":"Big data"},{"location":"mainpage.html#textual-interface","text":"Besides the functions implemented in GCSCommands you can send GCS commands as strings to the controller. Use read() for commands returning an answer, read_gcsdata() for commands returning GCS data and send() for non-answering commands. print gcs.read('POS?') print gcs.read_gcsdata('DRR? 1 100 1') gcs.send('MOV X 1.23') They return the raw string or GCS data from the controller. If errorcheck is enabled the error state is queried from the device automatically. It's recommended to use the provided functions instead of sending raw strings. In line with the C++ GCS DLL the functions ReadGCSCommand() and GcsCommandset() are also available. They will never query an error from the device. print gcs.ReadGCSCommand('POS?') gcs.GcsCommandset('MOV X 1.23')","title":"Textual interface"},{"location":"structure.html","text":"Package overview Diagram of PIPython PIPython is made of three layers. The commands layer provides GCS commands, the message layer handles GCS messages and the communication layer connects the device. The following diagram only shows the public items of the classes. Layers Commands layer Modules: pipython.gcscommands, pipython.gcsdevice A GCSCommands instance provides functions for the GCS commands and properties of the connected device and stages. For each GCS function there is an according \"Has\" function which returns True if the connected device supports this command. A GCSDevice instance inherits from GCSCommands and provides access to some properties and methods of the GCSDll , too. It needs a GCSDll instance and does not work with PISocket . GCSDevice is a context manager that will unload the GCSDll . Message layer Modules: pipython.gcsmessages A GCSMessage instance connects a communication gateway and a GCSCommands instance. It delivers the command string from a GCS command to the gateway. A proper line ending is made. For query commands it returns the answer from the gateway when it has received a GCS conforming end of message signature. Then optionally the error state is queried from the gateway. A background thread to read out big GCS data is provided. Comunication layer Modules: pipython.interfaces.pigateway, pipython.interfaces.gcsdll, pipython.interfaces.pisocket This is the gateway to a device. A connection to the device is established automatically, by provided commands or the device is already connected. Usually you will use an GCSDll instance which will be able to connect a GCS device over RS-232, USB, TCP/IP, GPIB, PCI and daisy chain. On platforms where no GCS DLL is available you can use the PISocket over TCP/IP. The GCSCommandsWrapper is for internal use only. The socket module is called pisocket to not interfere with the builtin module. But it is a plain python socket without any GCS implementations. Inherit from the interface (in terms of \"base class\") PIGateway when implementing other gateways.","title":"Structure"},{"location":"structure.html#package-overview","text":"","title":"Package overview"},{"location":"structure.html#diagram-of-pipython","text":"PIPython is made of three layers. The commands layer provides GCS commands, the message layer handles GCS messages and the communication layer connects the device. The following diagram only shows the public items of the classes.","title":"Diagram of PIPython"},{"location":"structure.html#layers","text":"","title":"Layers"},{"location":"structure.html#commands-layer","text":"Modules: pipython.gcscommands, pipython.gcsdevice A GCSCommands instance provides functions for the GCS commands and properties of the connected device and stages. For each GCS function there is an according \"Has\" function which returns True if the connected device supports this command. A GCSDevice instance inherits from GCSCommands and provides access to some properties and methods of the GCSDll , too. It needs a GCSDll instance and does not work with PISocket . GCSDevice is a context manager that will unload the GCSDll .","title":"Commands layer"},{"location":"structure.html#message-layer","text":"Modules: pipython.gcsmessages A GCSMessage instance connects a communication gateway and a GCSCommands instance. It delivers the command string from a GCS command to the gateway. A proper line ending is made. For query commands it returns the answer from the gateway when it has received a GCS conforming end of message signature. Then optionally the error state is queried from the gateway. A background thread to read out big GCS data is provided.","title":"Message layer"},{"location":"structure.html#comunication-layer","text":"Modules: pipython.interfaces.pigateway, pipython.interfaces.gcsdll, pipython.interfaces.pisocket This is the gateway to a device. A connection to the device is established automatically, by provided commands or the device is already connected. Usually you will use an GCSDll instance which will be able to connect a GCS device over RS-232, USB, TCP/IP, GPIB, PCI and daisy chain. On platforms where no GCS DLL is available you can use the PISocket over TCP/IP. The GCSCommandsWrapper is for internal use only. The socket module is called pisocket to not interfere with the builtin module. But it is a plain python socket without any GCS implementations. Inherit from the interface (in terms of \"base class\") PIGateway when implementing other gateways.","title":"Comunication layer"}]}